---
alwaysApply: false
---
# a User Selection Process

```typescript


interface UserSelection {
  type: 'custom' | 'bundle'
  selectedPodcasts?: string[] // Array of CuratedPodcast IDs
  selectedBundleId?: string   // Single CuratedBundle ID
}
```

### Collection Creation Logic

- for custom collections: Use user'\s selected sources
- For bundle collections: Use bundle'\s podcasts + fetch latest episodes
- New "Discover" Page - featuring bundles
- And editor'\s picks of the month

```typescript
 // If user selects individual podcasts

 if (selection.type === 'custom') {
 // Create collection with editable sources
 // User can add/remove individual podcasts
 }

 // If user selects a bundle
 if (selection.type === 'bundle') {
 // Create collection with read-only sources
 // Sources are automatically populated from bundle
 // User cannot edit the selection
}
```

---

### *Admin Interface**

 a. Admin User page with dashboard interface:   use exisiting blocks ( sidebar, dashboard) <https://ui.shadcn.com/blocks> and (buttons, cards, toasts, tables from) <https://ui.shadcn.com/docs/components>  when working on these tasks. And make use of the existing global.css theme for colors, and other theme related work. never add any new tailwind. always add styles to a module.css file. when you see repeating patterns move the styles into a shared folder for

### 5  "Podcasts / Collection" page layout

- use exisiting blocks ( sidebar, dashboard) <https://ui.shadcn.com/blocks> and (buttons, cards, toasts, tables from) <https://ui.shadcn.com/docs/components>  when working on these tasks. And make use of the existing global.css theme for colors, and other theme related work. never add any new tailwind. always add styles to a module.css file. when you see repeating patterns move the styles into a shared folder for

### 3. **Weekly Generation Logic**

## User Experience Flow

### **Option A: Custom Collection**

1. User browses 100 curated podcasts
2. Selects up to 5 individual shows
3. Can edit/add/remove shows anytime
4. Weekly generation uses their selected shows

### **Option B: Bundle Selection**

1. User browses pre-curated bundles
2. Selects one bundle (e.g., "Tech Weekly", "Business Insights")
3. Bundle is locked - cannot be edited
4. Weekly generation uses bundle's 5 shows

## Admin Management

```typescript
// Admin interface for managing bundles
interface BundleManagement {
  createBundle(name: string, description: string, podcastIds: string[])
  updateBundle(bundleId: string, podcastIds: string[])
  deactivateBundle(bundleId: string)
  viewBundleUsage(bundleId: string) // How many users selected this bundle
}
```

### 8.  Example Bundle Structure

```typescript
const exampleBundles = [
  {
    name: "Tech Weekly",
    description: "Latest in technology and innovation",
    podcasts: ["Lex Fridman", "The Vergecast", "Reply All", "Planet Money", "The Indicator"]
  },
  {
    name: "Business Insights",
    description: "Deep dives into business and economics",
    podcasts: ["How I Built This", "Masters of Scale", "The Tim Ferriss Show", "Freakonomics", "Planet Money"]
  },
  {
    name: "Science & Discovery",
    description: "Exploring the wonders of science",
    podcasts: ["Radiolab", "Science Friday", "Hidden Brain", "Invisibilia", "99% Invisible"]
  }
]
```

This approach gives users flexibility while maintaining the cost control you want. Users can either curate their own experience or trust your pre-curated bundles.

## Updated Schema (Simplified for 20-30 shows + 3 bundles)

```prisma
// Pre-curated individual podcasts (20-30 shows)
model CuratedPodcast {
  id          String   @id @default(uuid())
  name        String
  url         String
  description String?
  imageUrl    String?
  category    String   // "Technology", "Business", "Science", "News"
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with bundles
  bundlePodcasts CuratedBundlePodcast[]

  @@map("curated_podcasts")
}

// Pre-curated bundles (3 bundles, 5 shows each)
model CuratedBundle {
  id          String   @id @default(uuid())
  name        String   // "Tech Weekly", "Business Insights", "Science & Discovery"
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with podcasts
  bundlePodcasts CuratedBundlePodcast[]
  // Collections that selected this bundle
  collections Collection[]

  @@map("curated_bundles")
}

// Junction table for bundle-podcast relationship
model CuratedBundlePodcast {
  id              String        @id @default(uuid())
  bundleId        String        @map("bundle_id")
  podcastId       String        @map("podcast_id")
  bundle          CuratedBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  podcast         CuratedPodcast @relation(fields: [podcastId], references: [id], onDelete: Cascade)

  @@unique([bundleId, podcastId])
  @@map("curated_bundle_podcasts")
}

// Updated Collection model
model Collection {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  name        String
  status      String    @default("Draft")
  audioUrl    String?   @map("audio_url")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  generatedAt DateTime? @map("generated_at")
  lastGenerationDate DateTime? @map("last_generation_date")
  nextGenerationDate DateTime? @map("next_generation_date")
  isActive    Boolean   @default(true) @map("is_active")

  // Bundle selection (read-only) or custom selection (editable)
  isBundleSelection Boolean @default(false) @map("is_bundle_selection")
  selectedBundleId  String? @map("selected_bundle_id")
  selectedBundle    CuratedBundle? @relation(fields: [selectedBundleId], references: [id])

  // For custom selections (editable)
  sources     Source[]
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  episodes    Episode[]

  @@unique([userId]) // One collection per user
  @@map("collections")
}

// Add notifications
model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      String   // "episode_ready", "weekly_reminder"
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

// Update User model
model User {
  id            String       @id @default(cuid())
  name          String?
  email         String       @unique
  password      String
  image         String?
  emailVerified DateTime?
  emailNotifications Boolean @default(true) @map("email_notifications")
  inAppNotifications Boolean @default(true) @map("in_app_notifications")
  collections   Collection[]
  notifications Notification[]
}
```

## Initial Data Setup (20-30 shows + 3 bundles)

### **Curated Podcasts (25 shows)**

```typescript
const curatedPodcasts = [
  // Technology (8 shows)
  { name: "Lex Fridman Podcast", category: "Technology", url: "https://www.youtube.com/@lexfridman" },
  { name: "The Vergecast", category: "Technology", url: "https://www.youtube.com/@verge" },
  { name: "Reply All", category: "Technology", url: "https://gimletmedia.com/shows/reply-all" },
  { name: "Planet Money", category: "Technology", url: "https://www.npr.org/sections/money/" },
  { name: "The Indicator", category: "Technology", url: "https://www.npr.org/podcasts/510325/the-indicator-from-planet-money" },
  { name: "How I Built This", category: "Technology", url: "https://www.npr.org/podcasts/510313/how-i-built-this" },
  { name: "Masters of Scale", category: "Technology", url: "https://mastersofscale.com/" },
  { name: "The Tim Ferriss Show", category: "Technology", url: "https://tim.blog/podcast/" },

  // Business (8 shows)
  { name: "Freakonomics", category: "Business", url: "https://freakonomics.com/" },
  { name: "Hidden Brain", category: "Business", url: "https://www.npr.org/series/423302056/hidden-brain" },
  { name: "Invisibilia", category: "Business", url: "https://www.npr.org/podcasts/510307/invisibilia" },
  { name: "99% Invisible", category: "Business", url: "https://99percentinvisible.org/" },
  { name: "Radiolab", category: "Business", url: "https://www.wnycstudios.org/podcasts/radiolab" },
  { name: "Science Friday", category: "Business", url: "https://www.sciencefriday.com/" },
  { name: "This American Life", category: "Business", url: "https://www.thisamericanlife.org/" },
  { name: "Serial", category: "Business", url: "https://serialpodcast.org/" },

  // Science (5 shows)
  { name: "Star Talk Radio", category: "Science", url: "https://www.startalkradio.net/" },
  { name: "The Infinite Monkey Cage", category: "Science", url: "https://www.bbc.co.uk/programmes/b00snr0w" },
  { name: "Quirks and Quarks", category: "Science", url: "https://www.cbc.ca/radio/quirks" },
  { name: "Science Vs", category: "Science", url: "https://gimletmedia.com/shows/science-vs" },
  { name: "The Skeptics' Guide to the Universe", category: "Science", url: "https://www.theskepticsguide.org/" },

  // News (4 shows)
  { name: "The Daily", category: "News", url: "https://www.nytimes.com/column/the-daily" },
  { name: "Up First", category: "News", url: "https://www.npr.org/podcasts/510318/up-first" },
  { name: "Today, Explained", category: "News", url: "https://www.vox.com/today-explained-podcast" },
  { name: "The Intelligence", category: "News", url: "https://www.economist.com/podcasts/the-intelligence" }
]
```

### **3 Pre-curated Bundles**

```typescript
const curatedBundles = [
  {
    name: "Tech Weekly",
    description: "Latest in technology and innovation",
    podcasts: ["Lex Fridman Podcast", "The Vergecast", "Reply All", "Planet Money", "The Indicator"]
  },
  {
    name: "Business Insights",
    description: "Deep dives into business and economics",
    podcasts: ["How I Built This", "Masters of Scale", "The Tim Ferriss Show", "Freakonomics", "Planet Money"]
  },
  {
    name: "Science & Discovery",
    description: "Exploring the wonders of science",
    podcasts: ["Radiolab", "Science Friday", "Hidden Brain", "Invisibilia", "99% Invisible"]
  }
]
```

## Implementation Plan

### **Week 1: Database Setup**

ALREADY MIGRATED

1. Create migration for new schema
2. Seed database with 25 curated podcasts
3. Create 3 bundles with their podcast relationships
4. Add unique constraint for one collection per user

### **Week 2: User Interface Updates**

1. Update collection creation to show bundle vs custom selection
2. Create podcast selection interface (browse 25 shows)
3. Implement bundle selection (read-only after selection)
4. Add collection editing for custom selections

### **Week 3: Automation Infrastructure**

1. Set up weekly cron job (Friday midnight)
2. Create batch processing for active collections
3. Implement generation tracking (lastGenerationDate, nextGenerationDate)

### **Week 4: Notification System**

1. In-app notification bell
2. Email notification system
3. User notification preferences

## Quick Wins (Can start immediately)

### **1. Database Migration**

```sql
-- Add new tables
CREATE TABLE curated_podcasts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR NOT NULL,
  url VARCHAR NOT NULL,
  description TEXT,
  image_url VARCHAR,
  category VARCHAR NOT NULL,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE curated_bundles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR NOT NULL,
  description TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Add bundle fields to collections
ALTER TABLE collections ADD COLUMN is_bundle_selection BOOLEAN DEFAULT false;
ALTER TABLE collections ADD COLUMN selected_bundle_id UUID REFERENCES curated_bundles(id);
ALTER TABLE collections ADD CONSTRAINT unique_user_collection UNIQUE (user_id);
```

### **2. Seed Data Script**

```typescript
// scripts/seed-curated-content.ts
import prisma from '../lib/prisma'

async function seedCuratedContent() {
  // Seed podcasts
  const podcasts = await Promise.all(
    curatedPodcasts.map(podcast =>
      prisma.curatedPodcast.create({ data: podcast })
    )
  )

  // Seed bundles
  const bundles = await Promise.all(
    curatedBundles.map(async bundle => {
      const createdBundle = await prisma.curatedBundle.create({
        data: { name: bundle.name, description: bundle.description }
      })

      // Connect podcasts to bundle
      const podcastIds = await Promise.all(
        bundle.podcasts.map(name =>
          prisma.curatedPodcast.findFirst({ where: { name } })
        )
      )

      await Promise.all(
        podcastIds.map(podcast =>
          prisma.curatedBundlePodcast.create({
            data: {
              bundleId: createdBundle.id,
              podcastId: podcast!.id
            }
          })
        )
      )

      return createdBundle
    })
  )

  console.log(`Seeded ${podcasts.length} podcasts and ${bundles.length} bundles`)
}
```

This approach gives you a solid foundation with manageable scope. The 25 shows + 3 bundles provide enough variety while keeping the system simple to manage and test.

Would you like me to start with the database migration and seed data, or would you prefer to focus on a different aspect first?

```prisma
// Pre-curated individual podcasts (20-30 shows)
model CuratedPodcast {
  id          String   @id @default(uuid())
  name        String
  url         String
  description String?
  imageUrl    String?
  category    String   // "Technology", "Business", "Science", "News"
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with bundles
  bundlePodcasts CuratedBundlePodcast[]

  @@map("curated_podcasts")
}

// Pre-curated bundles (3 bundles, 5 shows each)
model CuratedBundle {
  id          String   @id @default(uuid())
  name        String   // "Tech Weekly", "Business Insights", "Science & Discovery"
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with podcasts
  bundlePodcasts CuratedBundlePodcast[]
  // Collections that selected this bundle
  collections Collection[]

  @@map("curated_bundles")
}

// Junction table for bundle-podcast relationship
model CuratedBundlePodcast {
  id              String        @id @default(uuid())
  bundleId        String        @map("bundle_id")
  podcastId       String        @map("podcast_id")
  bundle          CuratedBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  podcast         CuratedPodcast @relation(fields: [podcastId], references: [id], onDelete: Cascade)

  @@unique([bundleId, podcastId])
  @@map("curated_bundle_podcasts")
}

// Updated Collection model
model Collection {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  name        String
  status      String    @default("Draft")
  audioUrl    String?   @map("audio_url")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  generatedAt DateTime? @map("generated_at")
  lastGenerationDate DateTime? @map("last_generation_date")
  nextGenerationDate DateTime? @map("next_generation_date")
  isActive    Boolean   @default(true) @map("is_active")

  // Bundle selection (read-only) or custom selection (editable)
  isBundleSelection Boolean @default(false) @map("is_bundle_selection")
  selectedBundleId  String? @map("selected_bundle_id")
  selectedBundle    CuratedBundle? @relation(fields: [selectedBundleId], references: [id])

  // For custom selections (editable)
  sources     Source[]
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  episodes    Episode[]

  @@unique([userId]) // One collection per user
  @@map("collections")
}

// Add notifications
model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      String   // "episode_ready", "weekly_reminder"
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

// Update User model
model User {
  id            String       @id @default(cuid())
  name          String?
  email         String       @unique
  password      String
  image         String?
  emailVerified DateTime?
  emailNotifications Boolean @default(true) @map("email_notifications")
  inAppNotifications Boolean @default(true) @map("in_app_notifications")
  collections   Collection[]
  notifications Notification[]
}
```

```typescript
const curatedPodcasts = [
  // Technology (8 shows)
  { name: "Lex Fridman Podcast", category: "Technology", url: "https://www.youtube.com/@lexfridman" },
  { name: "The Vergecast", category: "Technology", url: "https://www.youtube.com/@verge" },
  { name: "Reply All", category: "Technology", url: "https://gimletmedia.com/shows/reply-all" },
  { name: "Planet Money", category: "Technology", url: "https://www.npr.org/sections/money/" },
  { name: "The Indicator", category: "Technology", url: "https://www.npr.org/podcasts/510325/the-indicator-from-planet-money" },
  { name: "How I Built This", category: "Technology", url: "https://www.npr.org/podcasts/510313/how-i-built-this" },
  { name: "Masters of Scale", category: "Technology", url: "https://mastersofscale.com/" },
  { name: "The Tim Ferriss Show", category: "Technology", url: "https://tim.blog/podcast/" },

  // Business (8 shows)
  { name: "Freakonomics", category: "Business", url: "https://freakonomics.com/" },
  { name: "Hidden Brain", category: "Business", url: "https://www.npr.org/series/423302056/hidden-brain" },
  { name: "Invisibilia", category: "Business", url: "https://www.npr.org/podcasts/510307/invisibilia" },
  { name: "99% Invisible", category: "Business", url: "https://99percentinvisible.org/" },
  { name: "Radiolab", category: "Business", url: "https://www.wnycstudios.org/podcasts/radiolab" },
  { name: "Science Friday", category: "Business", url: "https://www.sciencefriday.com/" },
  { name: "This American Life", category: "Business", url: "https://www.thisamericanlife.org/" },
  { name: "Serial", category: "Business", url: "https://serialpodcast.org/" },

  // Science (5 shows)
  { name: "Star Talk Radio", category: "Science", url: "https://www.startalkradio.net/" },
  { name: "The Infinite Monkey Cage", category: "Science", url: "https://www.bbc.co.uk/programmes/b00snr0w" },
  { name: "Quirks and Quarks", category: "Science", url: "https://www.cbc.ca/radio/quirks" },
  { name: "Science Vs", category: "Science", url: "https://gimletmedia.com/shows/science-vs" },
  { name: "The Skeptics' Guide to the Universe", category: "Science", url: "https://www.theskepticsguide.org/" },

  // News (4 shows)
  { name: "The Daily", category: "News", url: "https://www.nytimes.com/column/the-daily" },
  { name: "Up First", category: "News", url: "https://www.npr.org/podcasts/510318/up-first" },
  { name: "Today, Explained", category: "News", url: "https://www.vox.com/today-explained-podcast" },
  { name: "The Intelligence", category: "News", url: "https://www.economist.com/podcasts/the-intelligence" }
]
```

```typescript
const curatedBundles = [
  {
    name: "Tech Weekly",
    description: "Latest in technology and innovation",
    podcasts: ["Lex Fridman Podcast", "The Vergecast", "Reply All", "Planet Money", "The Indicator"]
  },
  {
    name: "Business Insights",
    description: "Deep dives into business and economics",
    podcasts: ["How I Built This", "Masters of Scale", "The Tim Ferriss Show", "Freakonomics", "Planet Money"]
  },
  {
    name: "Science & Discovery",
    description: "Exploring the wonders of science",
    podcasts: ["Radiolab", "Science Friday", "Hidden Brain", "Invisibilia", "99% Invisible"]
  }
]
```

```sql
-- Add new tables
CREATE TABLE curated_podcasts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR NOT NULL,
  url VARCHAR NOT NULL,
  description TEXT,
  image_url VARCHAR,
  category VARCHAR NOT NULL,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE curated_bundles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR NOT NULL,
  description TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Add bundle fields to collections
ALTER TABLE collections ADD COLUMN is_bundle_selection BOOLEAN DEFAULT false;
ALTER TABLE collections ADD COLUMN selected_bundle_id UUID REFERENCES curated_bundles(id);
ALTER TABLE collections ADD CONSTRAINT unique_user_collection UNIQUE (user_id);
```

```typescript
// scripts/seed-curated-content.ts
import prisma from '../lib/prisma'

async function seedCuratedContent() {
  // Seed podcasts
  const podcasts = await Promise.all(
    curatedPodcasts.map(podcast =>
      prisma.curatedPodcast.create({ data: podcast })
    )
  )

  // Seed bundles
  const bundles = await Promise.all(
    curatedBundles.map(async bundle => {
      const createdBundle = await prisma.curatedBundle.create({
        data: { name: bundle.name, description: bundle.description }
      })

      // Connect podcasts to bundle
      const podcastIds = await Promise.all(
        bundle.podcasts.map(name =>
          prisma.curatedPodcast.findFirst({ where: { name } })
        )
      )

      await Promise.all(
        podcastIds.map(podcast =>
          prisma.curatedBundlePodcast.create({
            data: {
              bundleId: createdBundle.id,
              podcastId: podcast!.id
            }
          })
        )
      )

      return createdBundle
    })
  )

  console.log(`Seeded ${podcasts.length} podcasts and ${bundles.length} bundles`)
}
```

Perfect! Let's start implementing this step by step. I'll begin with the database schema updates and seed data.

## Step 1: Update Prisma Schema

Now I'll update the schema with the new models and modifications:

```prisma:prisma/schema.prisma
// This is your Prisma schema file
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String       @id @default(cuid())
  name          String?
  email         String       @unique
  password      String
  image         String?
  emailVerified DateTime?
  emailNotifications Boolean @default(true) @map("email_notifications")
  inAppNotifications Boolean @default(true) @map("in_app_notifications")
  collections   Collection[]
  notifications Notification[]

  @@map("users")
}

model Collection {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  name        String
  status      String    @default("Draft")
  audioUrl    String?   @map("audio_url")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  generatedAt DateTime? @map("generated_at")
  lastGenerationDate DateTime? @map("last_generation_date")
  nextGenerationDate DateTime? @map("next_generation_date")
  isActive    Boolean   @default(true) @map("is_active")

  // Bundle selection (read-only) or custom selection (editable)
  isBundleSelection Boolean @default(false) @map("is_bundle_selection")
  selectedBundleId  String? @map("selected_bundle_id")
  selectedBundle    CuratedBundle? @relation(fields: [selectedBundleId], references: [id])

  // For custom selections (editable)
  sources     Source[]
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  episodes    Episode[]

  @@unique([userId]) // One collection per user
  @@map("collections")
}

model Source {
  id           String     @id @default(uuid())
  collectionId String     @map("collection_id")
  name         String
  url          String
  imageUrl     String?    @map("image_url")
  createdAt    DateTime   @default(now()) @map("created_at")
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  episodes     Episode[]

  @@map("sources")
}

model Episode {
  id           String     @id @default(uuid())
  title        String
  description  String?
  audioUrl     String
  imageUrl     String?
  publishedAt  DateTime?
  createdAt    DateTime   @default(now())
  sourceId     String     @map("source_id")
  source       Source     @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  collectionId String     @map("collection_id")
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@map("episodes")
}

// Pre-curated individual podcasts (25 shows)
model CuratedPodcast {
  id          String   @id @default(uuid())
  name        String
  url         String
  description String?
  imageUrl    String?
  category    String   // "Technology", "Business", "Science", "News"
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with bundles
  bundlePodcasts CuratedBundlePodcast[]

  @@map("curated_podcasts")
}

// Pre-curated bundles (3 bundles, 5 shows each)
model CuratedBundle {
  id          String   @id @default(uuid())
  name        String   // "Tech Weekly", "Business Insights", "Science & Discovery"
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with podcasts
  bundlePodcasts CuratedBundlePodcast[]
  // Collections that selected this bundle
  collections Collection[]

  @@map("curated_bundles")
}

// Junction table for bundle-podcast relationship
model CuratedBundlePodcast {
  id              String        @id @default(uuid())
  bundleId        String        @map("bundle_id")
  podcastId       String        @map("podcast_id")
  bundle          CuratedBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  podcast         CuratedPodcast @relation(fields: [podcastId], references: [id], onDelete: Cascade)

  @@unique([bundleId, podcastId])
  @@map("curated_bundle_podcasts")
}

// Notifications
model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      String   // "episode_ready", "weekly_reminder"
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}
```

## Step 2: Create Seed Data Script

```prisma
// This is your Prisma schema file
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String       @id @default(cuid())
  name          String?
  email         String       @unique
  password      String
  image         String?
  emailVerified DateTime?
  emailNotifications Boolean @default(true) @map("email_notifications")
  inAppNotifications Boolean @default(true) @map("in_app_notifications")
  collections   Collection[]
  notifications Notification[]

  @@map("users")
}

model Collection {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  name        String
  status      String    @default("Draft")
  audioUrl    String?   @map("audio_url")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  generatedAt DateTime? @map("generated_at")
  lastGenerationDate DateTime? @map("last_generation_date")
  nextGenerationDate DateTime? @map("next_generation_date")
  isActive    Boolean   @default(true) @map("is_active")

  // Bundle selection (read-only) or custom selection (editable)
  isBundleSelection Boolean @default(false) @map("is_bundle_selection")
  selectedBundleId  String? @map("selected_bundle_id")
  selectedBundle    CuratedBundle? @relation(fields: [selectedBundleId], references: [id])

  // For custom selections (editable)
  sources     Source[]
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  episodes    Episode[]

  @@unique([userId]) // One collection per user
  @@map("collections")
}

model Source {
  id           String     @id @default(uuid())
  collectionId String     @map("collection_id")
  name         String
  url          String
  imageUrl     String?    @map("image_url")
  createdAt    DateTime   @default(now()) @map("created_at")
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  episodes     Episode[]

  @@map("sources")
}

model Episode {
  id           String     @id @default(uuid())
  title        String
  description  String?
  audioUrl     String
  imageUrl     String?
  publishedAt  DateTime?
  createdAt    DateTime   @default(now())
  sourceId     String     @map("source_id")
  source       Source     @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  collectionId String     @map("collection_id")
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@map("episodes")
}

// Pre-curated individual podcasts (25 shows)
model CuratedPodcast {
  id          String   @id @default(uuid())
  name        String
  url         String
  description String?
  imageUrl    String?
  category    String   // "Technology", "Business", "Science", "News"
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with bundles
  bundlePodcasts CuratedBundlePodcast[]

  @@map("curated_podcasts")
}

// Pre-curated bundles (3 bundles, 5 shows each)
model CuratedBundle {
  id          String   @id @default(uuid())
  name        String   // "Tech Weekly", "Business Insights", "Science & Discovery"
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with podcasts
  bundlePodcasts CuratedBundlePodcast[]
  // Collections that selected this bundle
  collections Collection[]

  @@map("curated_bundles")
}

// Junction table for bundle-podcast relationship
model CuratedBundlePodcast {
  id              String        @id @default(uuid())
  bundleId        String        @map("bundle_id")
  podcastId       String        @map("podcast_id")
  bundle          CuratedBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  podcast         CuratedPodcast @relation(fields: [podcastId], references: [id], onDelete: Cascade)

  @@unique([bundleId, podcastId])
  @@map("curated_bundle_podcasts")
}

// Notifications
model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      String   // "episode_ready", "weekly_reminder"
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}
```

Now I'll create a new seed script for the curated content:

```typescript:scripts/seed-curated-content.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// 25 curated podcasts
const curatedPodcasts = [
  // Technology (8 shows)
  {
    name: "Lex Fridman Podcast",
    category: "Technology",
    url: "https://www.youtube.com/@lexfridman",
    description: "Conversations about science, technology, history, philosophy and the nature of intelligence, consciousness, love, and power."
  },
  {
    name: "The Vergecast",
    category: "Technology",
    url: "https://www.youtube.com/@verge",
    description: "The flagship podcast of The Verge... and the internet."
  },
  {
    name: "Reply All",
    category: "Technology",
    url: "https://gimletmedia.com/shows/reply-all",
    description: "A podcast about modern life and the internet."
  },
  {
    name: "Planet Money",
    category: "Technology",
    url: "https://www.npr.org/sections/money/",
    description: "The economy explained. Imagine you could call up a friend and say, 'Meet me at the bar and tell me what's going on with the economy.'"
  },
  {
    name: "The Indicator",
    category: "Technology",
    url: "https://www.npr.org/podcasts/510325/the-indicator-from-planet-money",
    description: "A little show about big ideas. From the people who make Planet Money."
  },
  {
    name: "How I Built This",
    category: "Technology",
    url: "https://www.npr.org/podcasts/510313/how-i-built-this",
    description: "Stories behind some of the world's best known companies."
  },
  {
    name: "Masters of Scale",
    category: "Technology",
    url: "https://mastersofscale.com/",
    description: "LinkedIn co-founder and Greylock partner Reid Hoffman shares startup stories and entrepreneurial insights."
  },
  {
    name: "The Tim Ferriss Show",
    category: "Technology",
    url: "https://tim.blog/podcast/",
    description: "Interviews with world-class performers to extract tools and tactics you can use."
  },

  // Business (8 shows)
  {
    name: "Freakonomics",
    category: "Business",
    url: "https://freakonomics.com/",
    description: "Discover the hidden side of everything with Stephen J. Dubner."
  },
  {
    name: "Hidden Brain",
    category: "Business",
    url: "https://www.npr.org/series/423302056/hidden-brain",
    description: "Shankar Vedantam uses science and storytelling to reveal the unconscious patterns that drive human behavior."
  },
  {
    name: "Invisibilia",
    category: "Business",
    url: "https://www.npr.org/podcasts/510307/invisibilia",
    description: "Unseeable forces control human behavior and shape our ideas, beliefs, and assumptions."
  },
  {
    name: "99% Invisible",
    category: "Business",
    url: "https://99percentinvisible.org/",
    description: "All about the thought that goes into the things we don't think about."
  },
  {
    name: "Radiolab",
    category: "Business",
    url: "https://www.wnycstudios.org/podcasts/radiolab",
    description: "Investigating a strange world."
  },
  {
    name: "Science Friday",
    category: "Business",
    url: "https://www.sciencefriday.com/",
    description: "Covering the outer reaches of space to the tiniest microbes in our bodies."
  },
  {
    name: "This American Life",
    category: "Business",
    url: "https://www.thisamericanlife.org/",
    description: "Each week we choose a theme and put together different kinds of stories on that theme."
  },
  {
    name: "Serial",
    category: "Business",
    url: "https://serialpodcast.org/",
    description: "Investigative journalism that tells one story—a true story—over the course of a season."
  },

  // Science (5 shows)
  {
    name: "Star Talk Radio",
    category: "Science",
    url: "https://www.startalkradio.net/",
    description: "Science, pop culture and comedy collide on StarTalk Radio."
  },
  {
    name: "The Infinite Monkey Cage",
    category: "Science",
    url: "https://www.bbc.co.uk/programmes/b00snr0w",
    description: "Witty, irreverent look at the world through scientists' eyes."
  },
  {
    name: "Quirks and Quarks",
    category: "Science",
    url: "https://www.cbc.ca/radio/quirks",
    description: "Canada's most popular science radio program."
  },
  {
    name: "Science Vs",
    category: "Science",
    url: "https://gimletmedia.com/shows/science-vs",
    description: "Science Vs takes on fads, trends, and the opinionated mob to find out what's fact, what's not, and what's somewhere in between."
  },
  {
    name: "The Skeptics' Guide to the Universe",
    category: "Science",
    url: "https://www.theskepticsguide.org/",
    description: "A weekly science podcast discussing the latest science news with scientific skepticism."
  },

  // News (4 shows)
  {
    name: "The Daily",
    category: "News",
    url: "https://www.nytimes.com/column/the-daily",
    description: "The biggest stories of our time, told by the best journalists in the world."
  },
  {
    name: "Up First",
    category: "News",
    url: "https://www.npr.org/podcasts/510318/up-first",
    description: "The news you need to start your day."
  },
  {
    name: "Today, Explained",
    category: "News",
    url: "https://www.vox.com/today-explained-podcast",
    description: "Vox's daily explainer podcast."
  },
  {
    name: "The Intelligence",
    category: "News",
    url: "https://www.economist.com/podcasts/the-intelligence",
    description: "The Economist's daily podcast on the news that matters."
  }
];

// 3 pre-curated bundles
const curatedBundles = [
  {
    name: "Tech Weekly",
    description: "Latest in technology and innovation",
    podcasts: ["Lex Fridman Podcast", "The Vergecast", "Reply All", "Planet Money", "The Indicator"]
  },
  {
    name: "Business Insights",
    description: "Deep dives into business and economics",
    podcasts: ["How I Built This", "Masters of Scale", "The Tim Ferriss Show", "Freakonomics", "Planet Money"]
  },
  {
    name: "Science & Discovery",
    description: "Exploring the wonders of science",
    podcasts: ["Radiolab", "Science Friday", "Hidden Brain", "Invisibilia", "99% Invisible"]
  }
];

async function seedCuratedContent() {
  console.log('🌱 Starting curated content seed...');

  try {
    // Clean up existing curated content
    await prisma.curatedBundlePodcast.deleteMany({});
    await prisma.curatedBundle.deleteMany({});
    await prisma.curatedPodcast.deleteMany({});

    console.log('✅ Cleaned up existing curated content');

    // Seed podcasts
    console.log('📻 Creating curated podcasts...');
    const createdPodcasts = await Promise.all(
      curatedPodcasts.map(podcast =>
        prisma.curatedPodcast.create({ data: podcast })
      )
    );
    console.log(`✅ Created ${createdPodcasts.length} podcasts`);

    // Seed bundles
    console.log('📦 Creating curated bundles...');
    const createdBundles = await Promise.all(
      curatedBundles.map(async bundle => {
        const createdBundle = await prisma.curatedBundle.create({
          data: {
            name: bundle.name,
            description: bundle.description
          }
        });

        // Find podcasts for this bundle
        const bundlePodcasts = await Promise.all(
          bundle.podcasts.map(name =>
            prisma.curatedPodcast.findFirst({
              where: { name },
              select: { id: true }
            })
          )
        );

        // Connect podcasts to bundle
        await Promise.all(
          bundlePodcasts.map(podcast =>
            prisma.curatedBundlePodcast.create({
              data: {
                bundleId: createdBundle.id,
                podcastId: podcast!.id
              }
            })
          )
        );

        return createdBundle;
      })
    );

    console.log(`✅ Created ${createdBundles.length} bundles with podcast connections`);

    // Verify the data
    const podcastCount = await prisma.curatedPodcast.count();
    const bundleCount = await prisma.curatedBundle.count();
    const bundlePodcastCount = await prisma.curatedBundlePodcast.count();

    console.log('\n📊 Seed Summary:');
    console.log(`   Podcasts: ${podcastCount}`);
    console.log(`   Bundles: ${bundleCount}`);
    console.log(`   Bundle-Podcast connections: ${bundlePodcastCount}`);

    console.log('\n🎉 Curated content seeding completed successfully!');

  } catch (error) {
    console.error('❌ Error seeding curated content:', error);
    throw error;
  }
}

// Run the seed function
seedCuratedContent()
  .catch((e) => {
    console.error('❌ Seed failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

## Step 3: Create Migration

Now let's create the migration for the schema changes:

```bash
# Run this command to generate the migration
npx prisma migrate dev --name add_curated_content_and_notifications
```

## Step 4: Update Package.json Scripts

Let's add a script to run the curated content seed:

```json:package.json
{
  "scripts": {
    // ... existing scripts
    "seed:curated": "tsx scripts/seed-curated-content.ts"
  }
}
```

## Step 5: Run the Implementation

Here's what you need to do:

1. **Update the schema file** with the new models I provided above
2. **Create the seed script** in `scripts/seed-curated-content.ts`
3. **Run the migration**:

   ```bash
   npx prisma migrate dev --name add_curated_content_and_notifications
   ```

4. **Run the seed script**:

   ```bash
   npm run seed:curated
   ```

## Step 6: Verify the Setup

After running the migration and seed, you can verify everything worked by checking:

```typescript
// Test script to verify the data
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function verifySeed() {
  const podcasts = await prisma.curatedPodcast.findMany({
    include: { bundlePodcasts: { include: { bundle: true } } }
  });

  const bundles = await prisma.curatedBundle.findMany({
    include: { bundlePodcasts: { include: { podcast: true } } }
  });

  console.log('Podcasts:', podcasts.length);
  console.log('Bundles:', bundles.length);

  bundles.forEach(bundle => {
    console.log(`${bundle.name}: ${bundle.bundlePodcasts.length} podcasts`);
  });
}

verifySeed();
```

This gives you:

- ✅ 25 curated podcasts across 4 categories
- ✅ 3 pre-curated bundles with 5 shows each
- ✅ Updated schema with bundle selection support
- ✅ Notification system ready
- ✅ One collection per user constraint

Ready to proceed with the next steps?

```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// 25 curated podcasts
const curatedPodcasts = [
  // Technology (8 shows)
  {
    name: "Lex Fridman Podcast",
    category: "Technology",
    url: "https://www.youtube.com/@lexfridman",
    description: "Conversations about science, technology, history, philosophy and the nature of intelligence, consciousness, love, and power."
  },
  {
    name: "The Vergecast",
    category: "Technology",
    url: "https://www.youtube.com/@verge",
    description: "The flagship podcast of The Verge... and the internet."
  },
  {
    name: "Reply All",
    category: "Technology",
    url: "https://gimletmedia.com/shows/reply-all",
    description: "A podcast about modern life and the internet."
  },
  {
    name: "Planet Money",
    category: "Technology",
    url: "https://www.npr.org/sections/money/",
    description: "The economy explained. Imagine you could call up a friend and say, 'Meet me at the bar and tell me what's going on with the economy.'"
  },
  {
    name: "The Indicator",
    category: "Technology",
    url: "https://www.npr.org/podcasts/510325/the-indicator-from-planet-money",
    description: "A little show about big ideas. From the people who make Planet Money."
  },
  {
    name: "How I Built This",
    category: "Technology",
    url: "https://www.npr.org/podcasts/510313/how-i-built-this",
    description: "Stories behind some of the world's best known companies."
  },
  {
    name: "Masters of Scale",
    category: "Technology",
    url: "https://mastersofscale.com/",
    description: "LinkedIn co-founder and Greylock partner Reid Hoffman shares startup stories and entrepreneurial insights."
  },
  {
    name: "The Tim Ferriss Show",
    category: "Technology",
    url: "https://tim.blog/podcast/",
    description: "Interviews with world-class performers to extract tools and tactics you can use."
  },

  // Business (8 shows)
  {
    name: "Freakonomics",
    category: "Business",
    url: "https://freakonomics.com/",
    description: "Discover the hidden side of everything with Stephen J. Dubner."
  },
  {
    name: "Hidden Brain",
    category: "Business",
    url: "https://www.npr.org/series/423302056/hidden-brain",
    description: "Shankar Vedantam uses science and storytelling to reveal the unconscious patterns that drive human behavior."
  },
  {
    name: "Invisibilia",
    category: "Business",
    url: "https://www.npr.org/podcasts/510307/invisibilia",
    description: "Unseeable forces control human behavior and shape our ideas, beliefs, and assumptions."
  },
  {
    name: "99% Invisible",
    category: "Business",
    url: "https://99percentinvisible.org/",
    description: "All about the thought that goes into the things we don't think about."
  },
  {
    name: "Radiolab",
    category: "Business",
    url: "https://www.wnycstudios.org/podcasts/radiolab",
    description: "Investigating a strange world."
  },
  {
    name: "Science Friday",
    category: "Business",
    url: "https://www.sciencefriday.com/",
    description: "Covering the outer reaches of space to the tiniest microbes in our bodies."
  },
  {
    name: "This American Life",
    category: "Business",
    url: "https://www.thisamericanlife.org/",
    description: "Each week we choose a theme and put together different kinds of stories on that theme."
  },
  {
    name: "Serial",
    category: "Business",
    url: "https://serialpodcast.org/",
    description: "Investigative journalism that tells one story—a true story—over the course of a season."
  },

  // Science (5 shows)
  {
    name: "Star Talk Radio",
    category: "Science",
    url: "https://www.startalkradio.net/",
    description: "Science, pop culture and comedy collide on StarTalk Radio."
  },
  {
    name: "The Infinite Monkey Cage",
    category: "Science",
    url: "https://www.bbc.co.uk/programmes/b00snr0w",
    description: "Witty, irreverent look at the world through scientists' eyes."
  },
  {
    name: "Quirks and Quarks",
    category: "Science",
    url: "https://www.cbc.ca/radio/quirks",
    description: "Canada's most popular science radio program."
  },
  {
    name: "Science Vs",
    category: "Science",
    url: "https://gimletmedia.com/shows/science-vs",
    description: "Science Vs takes on fads, trends, and the opinionated mob to find out what's fact, what's not, and what's somewhere in between."
  },
  {
    name: "The Skeptics' Guide to the Universe",
    category: "Science",
    url: "https://www.theskepticsguide.org/",
    description: "A weekly science podcast discussing the latest science news with scientific skepticism."
  },

  // News (4 shows)
  {
    name: "The Daily",
    category: "News",
    url: "https://www.nytimes.com/column/the-daily",
    description: "The biggest stories of our time, told by the best journalists in the world."
  },
  {
    name: "Up First",
    category: "News",
    url: "https://www.npr.org/podcasts/510318/up-first",
    description: "The news you need to start your day."
  },
  {
    name: "Today, Explained",
    category: "News",
    url: "https://www.vox.com/today-explained-podcast",
    description: "Vox's daily explainer podcast."
  },
  {
    name: "The Intelligence",
    category: "News",
    url: "https://www.economist.com/podcasts/the-intelligence",
    description: "The Economist's daily podcast on the news that matters."
  }
];

// 3 pre-curated bundles
const curatedBundles = [
  {
    name: "Tech Weekly",
    description: "Latest in technology and innovation",
    podcasts: ["Lex Fridman Podcast", "The Vergecast", "Reply All", "Planet Money", "The Indicator"]
  },
  {
    name: "Business Insights",
    description: "Deep dives into business and economics",
    podcasts: ["How I Built This", "Masters of Scale", "The Tim Ferriss Show", "Freakonomics", "Planet Money"]
  },
  {
    name: "Science & Discovery",
    description: "Exploring the wonders of science",
    podcasts: ["Radiolab", "Science Friday", "Hidden Brain", "Invisibilia", "99% Invisible"]
  }
];

async function seedCuratedContent() {
  console.log('🌱 Starting curated content seed...');

  try {
    // Clean up existing curated content
    await prisma.curatedBundlePodcast.deleteMany({});
    await prisma.curatedBundle.deleteMany({});
    await prisma.curatedPodcast.deleteMany({});

    console.log('✅ Cleaned up existing curated content');

    // Seed podcasts
    console.log('📻 Creating curated podcasts...');
    const createdPodcasts = await Promise.all(
      curatedPodcasts.map(podcast =>
        prisma.curatedPodcast.create({ data: podcast })
      )
    );
    console.log(`✅ Created ${createdPodcasts.length} podcasts`);

    // Seed bundles
    console.log('📦 Creating curated bundles...');
    const createdBundles = await Promise.all(
      curatedBundles.map(async bundle => {
        const createdBundle = await prisma.curatedBundle.create({
          data: {
            name: bundle.name,
            description: bundle.description
          }
        });

        // Find podcasts for this bundle
        const bundlePodcasts = await Promise.all(
          bundle.podcasts.map(name =>
            prisma.curatedPodcast.findFirst({
              where: { name },
              select: { id: true }
            })
          )
        );

        // Connect podcasts to bundle
        await Promise.all(
          bundlePodcasts.map(podcast =>
            prisma.curatedBundlePodcast.create({
              data: {
                bundleId: createdBundle.id,
                podcastId: podcast!.id
              }
            })
          )
        );

        return createdBundle;
      })
    );

    console.log(`✅ Created ${createdBundles.length} bundles with podcast connections`);

    // Verify the data
    const podcastCount = await prisma.curatedPodcast.count();
    const bundleCount = await prisma.curatedBundle.count();
    const bundlePodcastCount = await prisma.curatedBundlePodcast.count();

    console.log('\n📊 Seed Summary:');
    console.log(`   Podcasts: ${podcastCount}`);
    console.log(`   Bundles: ${bundleCount}`);
    console.log(`   Bundle-Podcast connections: ${bundlePodcastCount}`);

    console.log('\n🎉 Curated content seeding completed successfully!');

  } catch (error) {
    console.error('❌ Error seeding curated content:', error);
    throw error;
  }
}

// Run the seed function
seedCuratedContent()
  .catch((e) => {
    console.error('❌ Seed failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// 25 curated podcasts
const curatedPodcasts = [
  // Technology (8 shows)
  {
    name: "Lex Fridman Podcast",
    category: "Technology",
    url: "https://www.youtube.com/@lexfridman",
    description: "Conversations about science, technology, history, philosophy and the nature of intelligence, consciousness, love, and power."
  },
  {
    name: "The Vergecast",
    category: "Technology",
    url: "https://www.youtube.com/@verge",
    description: "The flagship podcast of The Verge... and the internet."
  },
  {
    name: "Reply All",
    category: "Technology",
    url: "https://gimletmedia.com/shows/reply-all",
    description: "A podcast about modern life and the internet."
  },
  {
    name: "Planet Money",
    category: "Technology",
    url: "https://www.npr.org/sections/money/",
    description: "The economy explained. Imagine you could call up a friend and say, 'Meet me at the bar and tell me what's going on with the economy.'"
  },
  {
    name: "The Indicator",
    category: "Technology",
    url: "https://www.npr.org/podcasts/510325/the-indicator-from-planet-money",
    description: "A little show about big ideas. From the people who make Planet Money."
  },
  {
    name: "How I Built This",
    category: "Technology",
    url: "https://www.npr.org/podcasts/510313/how-i-built-this",
    description: "Stories behind some of the world's best known companies."
  },
  {
    name: "Masters of Scale",
    category: "Technology",
    url: "https://mastersofscale.com/",
    description: "LinkedIn co-founder and Greylock partner Reid Hoffman shares startup stories and entrepreneurial insights."
  },
  {
    name: "The Tim Ferriss Show",
    category: "Technology",
    url: "https://tim.blog/podcast/",
    description: "Interviews with world-class performers to extract tools and tactics you can use."
  },

  // Business (8 shows)
  {
    name: "Freakonomics",
    category: "Business",
    url: "https://freakonomics.com/",
    description: "Discover the hidden side of everything with Stephen J. Dubner."
  },
  {
    name: "Hidden Brain",
    category: "Business",
    url: "https://www.npr.org/series/423302056/hidden-brain",
    description: "Shankar Vedantam uses science and storytelling to reveal the unconscious patterns that drive human behavior."
  },
  {
    name: "Invisibilia",
    category: "Business",
    url: "https://www.npr.org/podcasts/510307/invisibilia",
    description: "Unseeable forces control human behavior and shape our ideas, beliefs, and assumptions."
  },
  {
    name: "99% Invisible",
    category: "Business",
    url: "https://99percentinvisible.org/",
    description: "All about the thought that goes into the things we don't think about."
  },
  {
    name: "Radiolab",
    category: "Business",
    url: "https://www.wnycstudios.org/podcasts/radiolab",
    description: "Investigating a strange world."
  },
  {
    name: "Science Friday",
    category: "Business",
    url: "https://www.sciencefriday.com/",
    description: "Covering the outer reaches of space to the tiniest microbes in our bodies."
  },
  {
    name: "This American Life",
    category: "Business",
    url: "https://www.thisamericanlife.org/",
    description: "Each week we choose a theme and put together different kinds of stories on that theme."
  },
  {
    name: "Serial",
    category: "Business",
    url: "https://serialpodcast.org/",
    description: "Investigative journalism that tells one story—a true story—over the course of a season."
  },

  // Science (5 shows)
  {
    name: "Star Talk Radio",
    category: "Science",
    url: "https://www.startalkradio.net/",
    description: "Science, pop culture and comedy collide on StarTalk Radio."
  },
  {
    name: "The Infinite Monkey Cage",
    category: "Science",
    url: "https://www.bbc.co.uk/programmes/b00snr0w",
    description: "Witty, irreverent look at the world through scientists' eyes."
  },
  {
    name: "Quirks and Quarks",
    category: "Science",
    url: "https://www.cbc.ca/radio/quirks",
    description: "Canada's most popular science radio program."
  },
  {
    name: "Science Vs",
    category: "Science",
    url: "https://gimletmedia.com/shows/science-vs",
    description: "Science Vs takes on fads, trends, and the opinionated mob to find out what's fact, what's not, and what's somewhere in between."
  },
  {
    name: "The Skeptics' Guide to the Universe",
    category: "Science",
    url: "https://www.theskepticsguide.org/",
    description: "A weekly science podcast discussing the latest science news with scientific skepticism."
  },

  // News (4 shows)
  {
    name: "The Daily",
    category: "News",
    url: "https://www.nytimes.com/column/the-daily",
    description: "The biggest stories of our time, told by the best journalists in the world."
  },
  {
    name: "Up First",
    category: "News",
    url: "https://www.npr.org/podcasts/510318/up-first",
    description: "The news you need to start your day."
  },
  {
    name: "Today, Explained",
    category: "News",
    url: "https://www.vox.com/today-explained-podcast",
    description: "Vox's daily explainer podcast."
  },
  {
    name: "The Intelligence",
    category: "News",
    url: "https://www.economist.com/podcasts/the-intelligence",
    description: "The Economist's daily podcast on the news that matters."
  }
];

// 3 pre-curated bundles
const curatedBundles = [
  {
    name: "Tech Weekly",
    description: "Latest in technology and innovation",
    podcasts: ["Lex Fridman Podcast", "The Vergecast", "Reply All", "Planet Money", "The Indicator"]
  },
  {
    name: "Business Insights",
    description: "Deep dives into business and economics",
    podcasts: ["How I Built This", "Masters of Scale", "The Tim Ferriss Show", "Freakonomics", "Planet Money"]
  },
  {
    name: "Science & Discovery",
    description: "Exploring the wonders of science",
    podcasts: ["Radiolab", "Science Friday", "Hidden Brain", "Invisibilia", "99% Invisible"]
  }
];

async function seedCuratedContent() {
  console.log('🌱 Starting curated content seed...');

  try {
    // Clean up existing curated content
    await prisma.curatedBundlePodcast.deleteMany({});
    await prisma.curatedBundle.deleteMany({});
    await prisma.curatedPodcast.deleteMany({});

    console.log('✅ Cleaned up existing curated content');

    // Seed podcasts
    console.log('📻 Creating curated podcasts...');
    const createdPodcasts = await Promise.all(
      curatedPodcasts.map(podcast =>
        prisma.curatedPodcast.create({ data: podcast })
      )
    );
    console.log(`✅ Created ${createdPodcasts.length} podcasts`);

    // Seed bundles
    console.log('📦 Creating curated bundles...');
    const createdBundles = await Promise.all(
      curatedBundles.map(async bundle => {
        const createdBundle = await prisma.curatedBundle.create({
          data: {
            name: bundle.name,
            description: bundle.description
          }
        });

        // Find podcasts for this bundle
        const bundlePodcasts = await Promise.all(
          bundle.podcasts.map(name =>
            prisma.curatedPodcast.findFirst({
              where: { name },
              select: { id: true }
            })
          )
        );

        // Connect podcasts to bundle
        await Promise.all(
          bundlePodcasts.map(podcast =>
            prisma.curatedBundlePodcast.create({
              data: {
                bundleId: createdBundle.id,
                podcastId: podcast!.id
              }
            })
          )
        );

        return createdBundle;
      })
    );

    console.log(`✅ Created ${createdBundles.length} bundles with podcast connections`);

    // Verify the data
    const podcastCount = await prisma.curatedPodcast.count();
    const bundleCount = await prisma.curatedBundle.count();
    const bundlePodcastCount = await prisma.curatedBundlePodcast.count();

    console.log('\n📊 Seed Summary:');
    console.log(`   Podcasts: ${podcastCount}`);
    console.log(`   Bundles: ${bundleCount}`);
    console.log(`   Bundle-Podcast connections: ${bundlePodcastCount}`);

    console.log('\n🎉 Curated content seeding completed successfully!');

  } catch (error) {
    console.error('❌ Error seeding curated content:', error);
    throw error;
  }
}

// Run the seed function
seedCuratedContent()
  .catch((e) => {
    console.error('❌ Seed failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

```shellscript
# Run this command to generate the migration
npx prisma migrate dev --name add_curated_content_and_notifications
```

```json
{
  "scripts": {
    // ... existing scripts
    "seed:curated": "tsx scripts/seed-curated-content.ts"
  }
}
```

```shellscript
   npx prisma migrate dev --name add_curated_content_and_notifications
```

```shellscript
   npm run seed:curated
```

```typescript
// Test script to verify the data
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function verifySeed() {
  const podcasts = await prisma.curatedPodcast.findMany({
    include: { bundlePodcasts: { include: { bundle: true } } }
  });

  const bundles = await prisma.curatedBundle.findMany({
    include: { bundlePodcasts: { include: { podcast: true } } }
  });

  console.log('Podcasts:', podcasts.length);
  console.log('Bundles:', bundles.length);

  bundles.forEach(bundle => {
    console.log(`${bundle.name}: ${bundle.bundlePodcasts.length} podcasts`);
  });
}

verifySeed();
```

---

**User**

add an optional image_url for the shows, and episodes, collections,bundles.
I think it make sense to start adding a model that will handle monthly subscriptions because I will have to charge the user for those api calls eventually. there will be a trial free tier for 1 week. then a premium subscription. nothing more. i dont want it complicated. think of building a schema for a stripe, link type integration in mind. the big player should all have similar expected data we send them i suspect. again the payment system must be non complex. montly based subsriptions, which can be canceled etc.

---

**Cursor**

Perfect! Let's add the image URLs and create a simple subscription model for Stripe integration. This will be straightforward and scalable.

## Updated Schema with Images and Subscription Model

```prisma:prisma/schema.prisma
// This is your Prisma schema file
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String       @id @default(cuid())
  name          String?
  email         String       @unique
  password      String
  image         String?
  emailVerified DateTime?
  emailNotifications Boolean @default(true) @map("email_notifications")
  inAppNotifications Boolean @default(true) @map("in_app_notifications")
  collections   Collection[]
  notifications Notification[]
  subscriptions Subscription[]

  @@map("users")
}

model Collection {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  name        String
  status      String    @default("Draft")
  audioUrl    String?   @map("audio_url")
  imageUrl    String?   @map("image_url")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  generatedAt DateTime? @map("generated_at")
  lastGenerationDate DateTime? @map("last_generation_date")
  nextGenerationDate DateTime? @map("next_generation_date")
  isActive    Boolean   @default(true) @map("is_active")

  // Bundle selection (read-only) or custom selection (editable)
  isBundleSelection Boolean @default(false) @map("is_bundle_selection")
  selectedBundleId  String? @map("selected_bundle_id")
  selectedBundle    CuratedBundle? @relation(fields: [selectedBundleId], references: [id])

  // For custom selections (editable)
  sources     Source[]
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  episodes    Episode[]

  @@unique([userId]) // One collection per user
  @@map("collections")
}

model Source {
  id           String     @id @default(uuid())
  collectionId String     @map("collection_id")
  name         String
  url          String
  imageUrl     String?    @map("image_url")
  createdAt    DateTime   @default(now()) @map("created_at")
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  episodes     Episode[]

  @@map("sources")
}

model Episode {
  id           String     @id @default(uuid())
  title        String
  description  String?
  audioUrl     String
  imageUrl     String?
  publishedAt  DateTime?
  createdAt    DateTime   @default(now())
  sourceId     String     @map("source_id")
  source       Source     @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  collectionId String     @map("collection_id")
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@map("episodes")
}

// Pre-curated individual podcasts (25 shows)
model CuratedPodcast {
  id          String   @id @default(uuid())
  name        String
  url         String
  description String?
  imageUrl    String?
  category    String   // "Technology", "Business", "Science", "News"
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with bundles
  bundlePodcasts CuratedBundlePodcast[]

  @@map("curated_podcasts")
}

// Pre-curated bundles (3 bundles, 5 shows each)
model CuratedBundle {
  id          String   @id @default(uuid())
  name        String   // "Tech Weekly", "Business Insights", "Science & Discovery"
  description String?
  imageUrl    String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with podcasts
  bundlePodcasts CuratedBundlePodcast[]
  // Collections that selected this bundle
  collections Collection[]

  @@map("curated_bundles")
}

// Junction table for bundle-podcast relationship
model CuratedBundlePodcast {
  id              String        @id @default(uuid())
  bundleId        String        @map("bundle_id")
  podcastId       String        @map("podcast_id")
  bundle          CuratedBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  podcast         CuratedPodcast @relation(fields: [podcastId], references: [id], onDelete: Cascade)

  @@unique([bundleId, podcastId])
  @@map("curated_bundle_podcasts")
}

// Notifications
model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      String   // "episode_ready", "weekly_reminder"
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

// Simple Subscription Model for Stripe Integration
model Subscription {
  id                    String    @id @default(uuid())
  userId                String    @map("user_id")
  stripeCustomerId      String?   @map("stripe_customer_id")
  stripeSubscriptionId  String?   @map("stripe_subscription_id")
  stripePriceId         String?   @map("stripe_price_id")
  status                String    @default("trialing") // "trialing", "active", "canceled", "past_due", "incomplete"
  currentPeriodStart    DateTime? @map("current_period_start")
  currentPeriodEnd      DateTime? @map("current_period_end")
  trialStart            DateTime? @map("trial_start")
  trialEnd              DateTime? @map("trial_end")
  canceledAt            DateTime? @map("canceled_at")
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")

  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}
```

## Updated Seed Data with Images

```typescript:scripts/seed-curated-content.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// 25 curated podcasts with images
const curatedPodcasts = [
  // Technology (8 shows)
  {
    name: "Lex Fridman Podcast",
    category: "Technology",
    url: "https://www.youtube.com/@lexfridman",
    description: "Conversations about science, technology, history, philosophy and the nature of intelligence, consciousness, love, and power.",
    imageUrl: "https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=400&h=400&fit=crop"
  },
  {
    name: "The Vergecast",
    category: "Technology",
    url: "https://www.youtube.com/@verge",
    description: "The flagship podcast of The Verge... and the internet.",
    imageUrl: "https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=400&h=400&fit=crop"
  },
  {
    name: "Reply All",
    category: "Technology",
    url: "https://gimletmedia.com/shows/reply-all",
    description: "A podcast about modern life and the internet.",
    imageUrl: "https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=400&h=400&fit=crop"
  },
  {
    name: "Planet Money",
    category: "Technology",
    url: "https://www.npr.org/sections/money/",
    description: "The economy explained. Imagine you could call up a friend and say, 'Meet me at the bar and tell me what's going on with the economy.'",
    imageUrl: "https://images.unsplash.com/photo-1554224155-6726b3ff858f?w=400&h=400&fit=crop"
  },
  {
    name: "The Indicator",
    category: "Technology",
    url: "https://www.npr.org/podcasts/510325/the-indicator-from-planet-money",
    description: "A little show about big ideas. From the people who make Planet Money.",
    imageUrl: "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=400&h=400&fit=crop"
  },
  {
    name: "How I Built This",
    category: "Technology",
    url: "https://www.npr.org/podcasts/510313/how-i-built-this",
    description: "Stories behind some of the world's best known companies.",
    imageUrl: "https://images.unsplash.com/photo-1556761175-b413da4baf72?w=400&h=400&fit=crop"
  },
  {
    name: "Masters of Scale",
    category: "Technology",
    url: "https://mastersofscale.com/",
    description: "LinkedIn co-founder and Greylock partner Reid Hoffman shares startup stories and entrepreneurial insights.",
    imageUrl: "https://images.unsplash.com/photo-1552664730-d307ca884978?w=400&h=400&fit=crop"
  },
  {
    name: "The Tim Ferriss Show",
    category: "Technology",
    url: "https://tim.blog/podcast/",
    description: "Interviews with world-class performers to extract tools and tactics you can use.",
    imageUrl: "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=400&fit=crop"
  },

  // Business (8 shows)
  {
    name: "Freakonomics",
    category: "Business",
    url: "https://freakonomics.com/",
    description: "Discover the hidden side of everything with Stephen J. Dubner.",
    imageUrl: "https://images.unsplash.com/photo-1556761175-4acf4c6d6c96?w=400&h=400&fit=crop"
  },
  {
    name: "Hidden Brain",
    category: "Business",
    url: "https://www.npr.org/series/423302056/hidden-brain",
    description: "Shankar Vedantam uses science and storytelling to reveal the unconscious patterns that drive human behavior.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },
  {
    name: "Invisibilia",
    category: "Business",
    url: "https://www.npr.org/podcasts/510307/invisibilia",
    description: "Unseeable forces control human behavior and shape our ideas, beliefs, and assumptions.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },
  {
    name: "99% Invisible",
    category: "Business",
    url: "https://99percentinvisible.org/",
    description: "All about the thought that goes into the things we don't think about.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },
  {
    name: "Radiolab",
    category: "Business",
    url: "https://www.wnycstudios.org/podcasts/radiolab",
    description: "Investigating a strange world.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },
  {
    name: "Science Friday",
    category: "Business",
    url: "https://www.sciencefriday.com/",
    description: "Covering the outer reaches of space to the tiniest microbes in our bodies.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },
  {
    name: "This American Life",
    category: "Business",
    url: "https://www.thisamericanlife.org/",
    description: "Each week we choose a theme and put together different kinds of stories on that theme.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },
  {
    name: "Serial",
    category: "Business",
    url: "https://serialpodcast.org/",
    description: "Investigative journalism that tells one story—a true story—over the course of a season.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },

  // Science (5 shows)
  {
    name: "Star Talk Radio",
    category: "Science",
    url: "https://www.startalkradio.net/",
    description: "Science, pop culture and comedy collide on StarTalk Radio.",
    imageUrl: "https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=400&fit=crop"
  },
  {
    name: "The Infinite Monkey Cage",
    category: "Science",
    url: "https://www.bbc.co.uk/programmes/b00snr0w",
    description: "Witty, irreverent look at the world through scientists' eyes.",
    imageUrl: "https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=400&fit=crop"
  },
  {
    name: "Quirks and Quarks",
    category: "Science",
    url: "https://www.cbc.ca/radio/quirks",
    description: "Canada's most popular science radio program.",
    imageUrl: "https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=400&fit=crop"
  },
  {
    name: "Science Vs",
    category: "Science",
    url: "https://gimletmedia.com/shows/science-vs",
    description: "Science Vs takes on fads, trends, and the opinionated mob to find out what's fact, what's not, and what's somewhere in between.",
    imageUrl: "https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=400&fit=crop"
  },
  {
    name: "The Skeptics' Guide to the Universe",
    category: "Science",
    url: "https://www.theskepticsguide.org/",
    description: "A weekly science podcast discussing the latest science news with scientific skepticism.",
    imageUrl: "https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=400&fit=crop"
  },

  // News (4 shows)
  {
    name: "The Daily",
    category: "News",
    url: "https://www.nytimes.com/column/the-daily",
    description: "The biggest stories of our time, told by the best journalists in the world.",
    imageUrl: "https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=400&fit=crop"
  },
  {
    name: "Up First",
    category: "News",
    url: "https://www.npr.org/podcasts/510318/up-first",
    description: "The news you need to start your day.",
    imageUrl: "https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=400&fit=crop"
  },
  {
    name: "Today, Explained",
    category: "News",
    url: "https://www.vox.com/today-explained-podcast",
    description: "Vox's daily explainer podcast.",
    imageUrl: "https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=400&fit=crop"
  },
  {
    name: "The Intelligence",
    category: "News",
    url: "https://www.economist.com/podcasts/the-intelligence",
    description: "The Economist's daily podcast on the news that matters.",
    imageUrl: "https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=400&fit=crop"
  }
];

// 3 pre-curated bundles with images
const curatedBundles = [
  {
    name: "Tech Weekly",
    description: "Latest in technology and innovation",
    imageUrl: "https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=400&h=400&fit=crop",
    podcasts: ["Lex Fridman Podcast", "The Vergecast", "Reply All", "Planet Money", "The Indicator"]
  },
  {
    name: "Business Insights",
    description: "Deep dives into business and economics",
    imageUrl: "https://images.unsplash.com/photo-1556761175-4acf4c6d6c96?w=400&h=400&fit=crop",
    podcasts: ["How I Built This", "Masters of Scale", "The Tim Ferriss Show", "Freakonomics", "Planet Money"]
  },
  {
    name: "Science & Discovery",
    description: "Exploring the wonders of science",
    imageUrl: "https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=400&fit=crop",
    podcasts: ["Radiolab", "Science Friday", "Hidden Brain", "Invisibilia", "99% Invisible"]
  }
];

async function seedCuratedContent() {
  console.log('🌱 Starting curated content seed...');

  try {
    // Clean up existing curated content
    await prisma.curatedBundlePodcast.deleteMany({});
    await prisma.curatedBundle.deleteMany({});
    await prisma.curatedPodcast.deleteMany({});

    console.log('✅ Cleaned up existing curated content');

    // Seed podcasts
    console.log('📻 Creating curated podcasts...');
    const createdPodcasts = await Promise.all(
      curatedPodcasts.map(podcast =>
        prisma.curatedPodcast.create({ data: podcast })
      )
    );
    console.log(`✅ Created ${createdPodcasts.length} podcasts`);

    // Seed bundles
    console.log('📦 Creating curated bundles...');
    const createdBundles = await Promise.all(
      curatedBundles.map(async bundle => {
        const createdBundle = await prisma.curatedBundle.create({
          data: {
            name: bundle.name,
            description: bundle.description,
            imageUrl: bundle.imageUrl
          }
        });

        // Find podcasts for this bundle
        const bundlePodcasts = await Promise.all(
          bundle.podcasts.map(name =>
            prisma.curatedPodcast.findFirst({
              where: { name },
              select: { id: true }
            })
          )
        );

        // Connect podcasts to bundle
        await Promise.all(
          bundlePodcasts.map(podcast =>
            prisma.curatedBundlePodcast.create({
              data: {
                bundleId: createdBundle.id,
                podcastId: podcast!.id
              }
            })
          )
        );

        return createdBundle;
      })
    );

    console.log(`✅ Created ${createdBundles.length} bundles with podcast connections`);

    // Verify the data
    const podcastCount = await prisma.curatedPodcast.count();
    const bundleCount = await prisma.curatedBundle.count();
    const bundlePodcastCount = await prisma.curatedBundlePodcast.count();

    console.log('\n📊 Seed Summary:');
    console.log(`   Podcasts: ${podcastCount}`);
    console.log(`   Bundles: ${bundleCount}`);
    console.log(`   Bundle-Podcast connections: ${bundlePodcastCount}`);

    console.log('\n🎉 Curated content seeding completed successfully!');

  } catch (error) {
    console.error('❌ Error seeding curated content:', error);
    throw error;
  }
}

// Run the seed function
seedCuratedContent()
  .catch((e) => {
    console.error('❌ Seed failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

## Subscription Service for Stripe Integration

```typescript:lib/subscription-service.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export interface SubscriptionTier {
  id: string;
  name: string;
  price: number;
  stripePriceId: string;
  features: string[];
}

export const SUBSCRIPTION_TIERS = {
  TRIAL: {
    id: 'trial',
    name: 'Free Trial',
    price: 0,
    stripePriceId: null,
    features: ['1 week trial', '1 collection', 'Weekly generation']
  },
  PREMIUM: {
    id: 'premium',
    name: 'Premium',
    price: 9.99,
    stripePriceId: process.env.STRIPE_PREMIUM_PRICE_ID,
    features: ['Unlimited collections', 'Weekly generation', 'Priority support']
  }
} as const;

export class SubscriptionService {
  // Create a new subscription (trial or paid)
  static async createSubscription(userId: string, tierId: string) {
    const tier = SUBSCRIPTION_TIERS[tierId as keyof typeof SUBSCRIPTION_TIERS];

    if (!tier) {
      throw new Error(`Invalid subscription tier: ${tierId}`);
    }

    const now = new Date();
    const trialEnd = tierId === 'trial' ? new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000) : null;

    return await prisma.subscription.create({
      data: {
        userId,
        status: tierId === 'trial' ? 'trialing' : 'active',
        trialStart: tierId === 'trial' ? now : null,
        trialEnd,
        currentPeriodStart: now,
        currentPeriodEnd: trialEnd || new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000), // 30 days
        stripePriceId: tier.stripePriceId
      }
    });
  }

  // Get user's current subscription
  static async getUserSubscription(userId: string) {
    return await prisma.subscription.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' }
    });
  }

  // Check if user has active subscription
  static async hasActiveSubscription(userId: string): Promise<boolean> {
    const subscription = await this.getUserSubscription(userId);

    if (!subscription) return false;

    const now = new Date();

    // Check if trial is still active
    if (subscription.status === 'trialing' && subscription.trialEnd && subscription.trialEnd > now) {
      return true;
    }

    // Check if paid subscription is active
    if (subscription.status === 'active' && subscription.currentPeriodEnd && subscription.currentPeriodEnd > now) {
      return true;
    }

    return false;
  }

  // Update subscription from Stripe webhook
  static async updateFromStripeWebhook(stripeSubscription: any) {
    const subscription = await prisma.subscription.findFirst({
      where: { stripeSubscriptionId: stripeSubscription.id }
    });

    if (!subscription) {
      throw new Error(`Subscription not found for Stripe ID: ${stripeSubscription.id}`);
    }

    return await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        status: stripeSubscription.status,
        currentPeriodStart: new Date(stripeSubscription.current_period_start * 1000),
        currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1000),
        canceledAt: stripeSubscription.canceled_at ? new Date(stripeSubscription.canceled_at * 1000) : null
      }
    });
  }

  // Cancel subscription
  static async cancelSubscription(userId: string) {
    const subscription = await this.getUserSubscription(userId);

    if (!subscription) {
      throw new Error('No subscription found');
    }

    return await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        status: 'canceled',
        canceledAt: new Date()
      }
    });
  }
}
```

## Stripe Integration Helper

```typescript:lib/stripe.ts
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16'
});

export class StripeService {
  // Create a customer
  static async createCustomer(email: string, name?: string) {
    return await stripe.customers.create({
      email,
      name,
      metadata: {
        source: 'podcast-app'
      }
    });
  }

  // Create a subscription
  static async createSubscription(customerId: string, priceId: string) {
    return await stripe.subscriptions.create({
      customer: customerId,
      items: [{ price: priceId }],
      payment_behavior: 'default_incomplete',
      payment_settings: { save_default_payment_method: 'on_subscription' },
      expand: ['latest_invoice.payment_intent']
    });
  }

  // Cancel a subscription
  static async cancelSubscription(subscriptionId: string) {
    return await stripe.subscriptions.cancel(subscriptionId);
  }

  // Create a checkout session
  static async createCheckoutSession(customerId: string, priceId: string, successUrl: string, cancelUrl: string) {
    return await stripe.checkout.sessions.create({
      customer: customerId,
      payment_method_types: ['card'],
      line_items: [{ price: priceId, quantity: 1 }],
      mode: 'subscription',
      success_url: successUrl,
      cancel_url: cancelUrl,
      allow_promotion_codes: true
    });
  }
}
```

## Environment Variables Needed

```env
# Stripe Configuration
STRIPE_SECRET_KEY=sk_test_...
STRIPE_PUBLISHABLE_KEY=pk_test_...
STRIPE_PREMIUM_PRICE_ID=price_...
STRIPE_WEBHOOK_SECRET=whsec_...
```

## Migration Command

```bash
# Run this to create the migration
npx prisma migrate dev --name add_images_and_subscriptions
```

This setup gives you:

✅ **Image URLs** for all models (collections, episodes, podcasts, bundles)
✅ **Simple subscription model** compatible with Stripe
✅ **Trial system** (1 week free)
✅ **Monthly billing** with easy cancellation
✅ **Webhook support** for Stripe events
✅ **Subscription status tracking**

The subscription model is designed to be simple but scalable. It handles:

- Trial periods
- Monthly billing
- Cancellations
- Stripe webhook updates
- Subscription status tracking

Ready to implement this?

```prisma
// This is your Prisma schema file
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String       @id @default(cuid())
  name          String?
  email         String       @unique
  password      String
  image         String?
  emailVerified DateTime?
  emailNotifications Boolean @default(true) @map("email_notifications")
  inAppNotifications Boolean @default(true) @map("in_app_notifications")
  collections   Collection[]
  notifications Notification[]
  subscriptions Subscription[]

  @@map("users")
}

model Collection {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  name        String
  status      String    @default("Draft")
  audioUrl    String?   @map("audio_url")
  imageUrl    String?   @map("image_url")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  generatedAt DateTime? @map("generated_at")
  lastGenerationDate DateTime? @map("last_generation_date")
  nextGenerationDate DateTime? @map("next_generation_date")
  isActive    Boolean   @default(true) @map("is_active")

  // Bundle selection (read-only) or custom selection (editable)
  isBundleSelection Boolean @default(false) @map("is_bundle_selection")
  selectedBundleId  String? @map("selected_bundle_id")
  selectedBundle    CuratedBundle? @relation(fields: [selectedBundleId], references: [id])

  // For custom selections (editable)
  sources     Source[]
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  episodes    Episode[]

  @@unique([userId]) // One collection per user
  @@map("collections")
}

model Source {
  id           String     @id @default(uuid())
  collectionId String     @map("collection_id")
  name         String
  url          String
  imageUrl     String?    @map("image_url")
  createdAt    DateTime   @default(now()) @map("created_at")
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  episodes     Episode[]

  @@map("sources")
}

model Episode {
  id           String     @id @default(uuid())
  title        String
  description  String?
  audioUrl     String
  imageUrl     String?
  publishedAt  DateTime?
  createdAt    DateTime   @default(now())
  sourceId     String     @map("source_id")
  source       Source     @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  collectionId String     @map("collection_id")
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@map("episodes")
}

// Pre-curated individual podcasts (25 shows)
model CuratedPodcast {
  id          String   @id @default(uuid())
  name        String
  url         String
  description String?
  imageUrl    String?
  category    String   // "Technology", "Business", "Science", "News"
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with bundles
  bundlePodcasts CuratedBundlePodcast[]

  @@map("curated_podcasts")
}

// Pre-curated bundles (3 bundles, 5 shows each)
model CuratedBundle {
  id          String   @id @default(uuid())
  name        String   // "Tech Weekly", "Business Insights", "Science & Discovery"
  description String?
  imageUrl    String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with podcasts
  bundlePodcasts CuratedBundlePodcast[]
  // Collections that selected this bundle
  collections Collection[]

  @@map("curated_bundles")
}

// Junction table for bundle-podcast relationship
model CuratedBundlePodcast {
  id              String        @id @default(uuid())
  bundleId        String        @map("bundle_id")
  podcastId       String        @map("podcast_id")
  bundle          CuratedBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  podcast         CuratedPodcast @relation(fields: [podcastId], references: [id], onDelete: Cascade)

  @@unique([bundleId, podcastId])
  @@map("curated_bundle_podcasts")
}

// Notifications
model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      String   // "episode_ready", "weekly_reminder"
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

// Simple Subscription Model for Stripe Integration
model Subscription {
  id                    String    @id @default(uuid())
  userId                String    @map("user_id")
  stripeCustomerId      String?   @map("stripe_customer_id")
  stripeSubscriptionId  String?   @map("stripe_subscription_id")
  stripePriceId         String?   @map("stripe_price_id")
  status                String    @default("trialing") // "trialing", "active", "canceled", "past_due", "incomplete"
  currentPeriodStart    DateTime? @map("current_period_start")
  currentPeriodEnd      DateTime? @map("current_period_end")
  trialStart            DateTime? @map("trial_start")
  trialEnd              DateTime? @map("trial_end")
  canceledAt            DateTime? @map("canceled_at")
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")

  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}
```

```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// 25 curated podcasts with images
const curatedPodcasts = [
  // Technology (8 shows)
  {
    name: "Lex Fridman Podcast",
    category: "Technology",
    url: "https://www.youtube.com/@lexfridman",
    description: "Conversations about science, technology, history, philosophy and the nature of intelligence, consciousness, love, and power.",
    imageUrl: "https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=400&h=400&fit=crop"
  },
  {
    name: "The Vergecast",
    category: "Technology",
    url: "https://www.youtube.com/@verge",
    description: "The flagship podcast of The Verge... and the internet.",
    imageUrl: "https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=400&h=400&fit=crop"
  },
  {
    name: "Reply All",
    category: "Technology",
    url: "https://gimletmedia.com/shows/reply-all",
    description: "A podcast about modern life and the internet.",
    imageUrl: "https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=400&h=400&fit=crop"
  },
  {
    name: "Planet Money",
    category: "Technology",
    url: "https://www.npr.org/sections/money/",
    description: "The economy explained. Imagine you could call up a friend and say, 'Meet me at the bar and tell me what's going on with the economy.'",
    imageUrl: "https://images.unsplash.com/photo-1554224155-6726b3ff858f?w=400&h=400&fit=crop"
  },
  {
    name: "The Indicator",
    category: "Technology",
    url: "https://www.npr.org/podcasts/510325/the-indicator-from-planet-money",
    description: "A little show about big ideas. From the people who make Planet Money.",
    imageUrl: "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=400&h=400&fit=crop"
  },
  {
    name: "How I Built This",
    category: "Technology",
    url: "https://www.npr.org/podcasts/510313/how-i-built-this",
    description: "Stories behind some of the world's best known companies.",
    imageUrl: "https://images.unsplash.com/photo-1556761175-b413da4baf72?w=400&h=400&fit=crop"
  },
  {
    name: "Masters of Scale",
    category: "Technology",
    url: "https://mastersofscale.com/",
    description: "LinkedIn co-founder and Greylock partner Reid Hoffman shares startup stories and entrepreneurial insights.",
    imageUrl: "https://images.unsplash.com/photo-1552664730-d307ca884978?w=400&h=400&fit=crop"
  },
  {
    name: "The Tim Ferriss Show",
    category: "Technology",
    url: "https://tim.blog/podcast/",
    description: "Interviews with world-class performers to extract tools and tactics you can use.",
    imageUrl: "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=400&fit=crop"
  },

  // Business (8 shows)
  {
    name: "Freakonomics",
    category: "Business",
    url: "https://freakonomics.com/",
    description: "Discover the hidden side of everything with Stephen J. Dubner.",
    imageUrl: "https://images.unsplash.com/photo-1556761175-4acf4c6d6c96?w=400&h=400&fit=crop"
  },
  {
    name: "Hidden Brain",
    category: "Business",
    url: "https://www.npr.org/series/423302056/hidden-brain",
    description: "Shankar Vedantam uses science and storytelling to reveal the unconscious patterns that drive human behavior.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },
  {
    name: "Invisibilia",
    category: "Business",
    url: "https://www.npr.org/podcasts/510307/invisibilia",
    description: "Unseeable forces control human behavior and shape our ideas, beliefs, and assumptions.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },
  {
    name: "99% Invisible",
    category: "Business",
    url: "https://99percentinvisible.org/",
    description: "All about the thought that goes into the things we don't think about.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },
  {
    name: "Radiolab",
    category: "Business",
    url: "https://www.wnycstudios.org/podcasts/radiolab",
    description: "Investigating a strange world.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },
  {
    name: "Science Friday",
    category: "Business",
    url: "https://www.sciencefriday.com/",
    description: "Covering the outer reaches of space to the tiniest microbes in our bodies.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },
  {
    name: "This American Life",
    category: "Business",
    url: "https://www.thisamericanlife.org/",
    description: "Each week we choose a theme and put together different kinds of stories on that theme.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },
  {
    name: "Serial",
    category: "Business",
    url: "https://serialpodcast.org/",
    description: "Investigative journalism that tells one story—a true story—over the course of a season.",
    imageUrl: "https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop"
  },

  // Science (5 shows)
  {
    name: "Star Talk Radio",
    category: "Science",
    url: "https://www.startalkradio.net/",
    description: "Science, pop culture and comedy collide on StarTalk Radio.",
    imageUrl: "https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=400&fit=crop"
  },
  {
    name: "The Infinite Monkey Cage",
    category: "Science",
    url: "https://www.bbc.co.uk/programmes/b00snr0w",
    description: "Witty, irreverent look at the world through scientists' eyes.",
    imageUrl: "https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=400&fit=crop"
  },
  {
    name: "Quirks and Quarks",
    category: "Science",
    url: "https://www.cbc.ca/radio/quirks",
    description: "Canada's most popular science radio program.",
    imageUrl: "https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=400&fit=crop"
  },
  {
    name: "Science Vs",
    category: "Science",
    url: "https://gimletmedia.com/shows/science-vs",
    description: "Science Vs takes on fads, trends, and the opinionated mob to find out what's fact, what's not, and what's somewhere in between.",
    imageUrl: "https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=400&fit=crop"
  },
  {
    name: "The Skeptics' Guide to the Universe",
    category: "Science",
    url: "https://www.theskepticsguide.org/",
    description: "A weekly science podcast discussing the latest science news with scientific skepticism.",
    imageUrl: "https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=400&fit=crop"
  },

  // News (4 shows)
  {
    name: "The Daily",
    category: "News",
    url: "https://www.nytimes.com/column/the-daily",
    description: "The biggest stories of our time, told by the best journalists in the world.",
    imageUrl: "https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=400&fit=crop"
  },
  {
    name: "Up First",
    category: "News",
    url: "https://www.npr.org/podcasts/510318/up-first",
    description: "The news you need to start your day.",
    imageUrl: "https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=400&fit=crop"
  },
  {
    name: "Today, Explained",
    category: "News",
    url: "https://www.vox.com/today-explained-podcast",
    description: "Vox's daily explainer podcast.",
    imageUrl: "https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=400&fit=crop"
  },
  {
    name: "The Intelligence",
    category: "News",
    url: "https://www.economist.com/podcasts/the-intelligence",
    description: "The Economist's daily podcast on the news that matters.",
    imageUrl: "https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=400&fit=crop"
  }
];

// 3 pre-curated bundles with images
const curatedBundles = [
  {
    name: "Tech Weekly",
    description: "Latest in technology and innovation",
    imageUrl: "https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=400&h=400&fit=crop",
    podcasts: ["Lex Fridman Podcast", "The Vergecast", "Reply All", "Planet Money", "The Indicator"]
  },
  {
    name: "Business Insights",
    description: "Deep dives into business and economics",
    imageUrl: "https://images.unsplash.com/photo-1556761175-4acf4c6d6c96?w=400&h=400&fit=crop",
    podcasts: ["How I Built This", "Masters of Scale", "The Tim Ferriss Show", "Freakonomics", "Planet Money"]
  },
  {
    name: "Science & Discovery",
    description: "Exploring the wonders of science",
    imageUrl: "https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=400&fit=crop",
    podcasts: ["Radiolab", "Science Friday", "Hidden Brain", "Invisibilia", "99% Invisible"]
  }
];

async function seedCuratedContent() {
  console.log('🌱 Starting curated content seed...');

  try {
    // Clean up existing curated content
    await prisma.curatedBundlePodcast.deleteMany({});
    await prisma.curatedBundle.deleteMany({});
    await prisma.curatedPodcast.deleteMany({});

    console.log('✅ Cleaned up existing curated content');

    // Seed podcasts
    console.log('📻 Creating curated podcasts...');
    const createdPodcasts = await Promise.all(
      curatedPodcasts.map(podcast =>
        prisma.curatedPodcast.create({ data: podcast })
      )
    );
    console.log(`✅ Created ${createdPodcasts.length} podcasts`);

    // Seed bundles
    console.log('📦 Creating curated bundles...');
    const createdBundles = await Promise.all(
      curatedBundles.map(async bundle => {
        const createdBundle = await prisma.curatedBundle.create({
          data: {
            name: bundle.name,
            description: bundle.description,
            imageUrl: bundle.imageUrl
          }
        });

        // Find podcasts for this bundle
        const bundlePodcasts = await Promise.all(
          bundle.podcasts.map(name =>
            prisma.curatedPodcast.findFirst({
              where: { name },
              select: { id: true }
            })
          )
        );

        // Connect podcasts to bundle
        await Promise.all(
          bundlePodcasts.map(podcast =>
            prisma.curatedBundlePodcast.create({
              data: {
                bundleId: createdBundle.id,
                podcastId: podcast!.id
              }
            })
          )
        );

        return createdBundle;
      })
    );

    console.log(`✅ Created ${createdBundles.length} bundles with podcast connections`);

    // Verify the data
    const podcastCount = await prisma.curatedPodcast.count();
    const bundleCount = await prisma.curatedBundle.count();
    const bundlePodcastCount = await prisma.curatedBundlePodcast.count();

    console.log('\n📊 Seed Summary:');
    console.log(`   Podcasts: ${podcastCount}`);
    console.log(`   Bundles: ${bundleCount}`);
    console.log(`   Bundle-Podcast connections: ${bundlePodcastCount}`);

    console.log('\n🎉 Curated content seeding completed successfully!');

  } catch (error) {
    console.error('❌ Error seeding curated content:', error);
    throw error;
  }
}

// Run the seed function
seedCuratedContent()
  .catch((e) => {
    console.error('❌ Seed failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export interface SubscriptionTier {
  id: string;
  name: string;
  price: number;
  stripePriceId: string;
  features: string[];
}

export const SUBSCRIPTION_TIERS = {
  TRIAL: {
    id: 'trial',
    name: 'Free Trial',
    price: 0,
    stripePriceId: null,
    features: ['1 week trial', '1 collection', 'Weekly generation']
  },
  PREMIUM: {
    id: 'premium',
    name: 'Premium',
    price: 9.99,
    stripePriceId: process.env.STRIPE_PREMIUM_PRICE_ID,
    features: ['Unlimited collections', 'Weekly generation', 'Priority support']
  }
} as const;

export class SubscriptionService {
  // Create a new subscription (trial or paid)
  static async createSubscription(userId: string, tierId: string) {
    const tier = SUBSCRIPTION_TIERS[tierId as keyof typeof SUBSCRIPTION_TIERS];

    if (!tier) {
      throw new Error(`Invalid subscription tier: ${tierId}`);
    }

    const now = new Date();
    const trialEnd = tierId === 'trial' ? new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000) : null;

    return await prisma.subscription.create({
      data: {
        userId,
        status: tierId === 'trial' ? 'trialing' : 'active',
        trialStart: tierId === 'trial' ? now : null,
        trialEnd,
        currentPeriodStart: now,
        currentPeriodEnd: trialEnd || new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000), // 30 days
        stripePriceId: tier.stripePriceId
      }
    });
  }

  // Get user's current subscription
  static async getUserSubscription(userId: string) {
    return await prisma.subscription.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' }
    });
  }

  // Check if user has active subscription
  static async hasActiveSubscription(userId: string): Promise<boolean> {
    const subscription = await this.getUserSubscription(userId);

    if (!subscription) return false;

    const now = new Date();

    // Check if trial is still active
    if (subscription.status === 'trialing' && subscription.trialEnd && subscription.trialEnd > now) {
      return true;
    }

    // Check if paid subscription is active
    if (subscription.status === 'active' && subscription.currentPeriodEnd && subscription.currentPeriodEnd > now) {
      return true;
    }

    return false;
  }

  // Update subscription from Stripe webhook
  static async updateFromStripeWebhook(stripeSubscription: any) {
    const subscription = await prisma.subscription.findFirst({
      where: { stripeSubscriptionId: stripeSubscription.id }
    });

    if (!subscription) {
      throw new Error(`Subscription not found for Stripe ID: ${stripeSubscription.id}`);
    }

    return await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        status: stripeSubscription.status,
        currentPeriodStart: new Date(stripeSubscription.current_period_start * 1000),
        currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1000),
        canceledAt: stripeSubscription.canceled_at ? new Date(stripeSubscription.canceled_at * 1000) : null
      }
    });
  }

  // Cancel subscription
  static async cancelSubscription(userId: string) {
    const subscription = await this.getUserSubscription(userId);

    if (!subscription) {
      throw new Error('No subscription found');
    }

    return await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        status: 'canceled',
        canceledAt: new Date()
      }
    });
  }
}
```

```typescript
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16'
});

export class StripeService {
  // Create a customer
  static async createCustomer(email: string, name?: string) {
    return await stripe.customers.create({
      email,
      name,
      metadata: {
        source: 'podcast-app'
      }
    });
  }

  // Create a subscription
  static async createSubscription(customerId: string, priceId: string) {
    return await stripe.subscriptions.create({
      customer: customerId,
      items: [{ price: priceId }],
      payment_behavior: 'default_incomplete',
      payment_settings: { save_default_payment_method: 'on_subscription' },
      expand: ['latest_invoice.payment_intent']
    });
  }

  // Cancel a subscription
  static async cancelSubscription(subscriptionId: string) {
    return await stripe.subscriptions.cancel(subscriptionId);
  }

  // Create a checkout session
  static async createCheckoutSession(customerId: string, priceId: string, successUrl: string, cancelUrl: string) {
    return await stripe.checkout.sessions.create({
      customer: customerId,
      payment_method_types: ['card'],
      line_items: [{ price: priceId, quantity: 1 }],
      mode: 'subscription',
      success_url: successUrl,
      cancel_url: cancelUrl,
      allow_promotion_codes: true
    });
  }
}
```

```env
# Stripe Configuration
STRIPE_SECRET_KEY=sk_test_...
STRIPE_PUBLISHABLE_KEY=pk_test_...
STRIPE_PREMIUM_PRICE_ID=price_...
STRIPE_WEBHOOK_SECRET=whsec_...
```

```shellscript
# Run this to create the migration
npx prisma migrate dev --name add_images_and_subscriptions
```

---

**User**

Im thinking about using @<https://link.com/> - im in south africa and stripe have some issues with its operations here.

---

**Cursor**

Great choice! Link is an excellent alternative to Stripe, especially for South African businesses. It's designed to work seamlessly with South African payment methods and has much better local support than Stripe.

Let me update the subscription service to work with Link instead of Stripe:

## Updated Subscription Service for Link Integration

```typescript:lib/link-service.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export interface SubscriptionTier {
  id: string;
  name: string;
  price: number;
  linkPriceId: string;
  features: string[];
}

export const SUBSCRIPTION_TIERS = {
  TRIAL: {
    id: 'trial',
    name: 'Free Trial',
    price: 0,
    linkPriceId: null,
    features: ['1 week trial', '1 collection', 'Weekly generation']
  },
  PREMIUM: {
    id: 'premium',
    name: 'Premium',
    price: 99, // R99/month in ZAR
    linkPriceId: process.env.LINK_PREMIUM_PRICE_ID,
    features: ['Unlimited collections', 'Weekly generation', 'Priority support']
  }
} as const;

export class LinkService {
  // Create a new subscription (trial or paid)
  static async createSubscription(userId: string, tierId: string) {
    const tier = SUBSCRIPTION_TIERS[tierId as keyof typeof SUBSCRIPTION_TIERS];

    if (!tier) {
      throw new Error(`Invalid subscription tier: ${tierId}`);
    }

    const now = new Date();
    const trialEnd = tierId === 'trial' ? new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000) : null;

    return await prisma.subscription.create({
      data: {
        userId,
        status: tierId === 'trial' ? 'trialing' : 'active',
        trialStart: tierId === 'trial' ? now : null,
        trialEnd,
        currentPeriodStart: now,
        currentPeriodEnd: trialEnd || new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000), // 30 days
        linkPriceId: tier.linkPriceId
      }
    });
  }

  // Get user's current subscription
  static async getUserSubscription(userId: string) {
    return await prisma.subscription.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' }
    });
  }

  // Check if user has active subscription
  static async hasActiveSubscription(userId: string): Promise<boolean> {
    const subscription = await this.getUserSubscription(userId);

    if (!subscription) return false;

    const now = new Date();

    // Check if trial is still active
    if (subscription.status === 'trialing' && subscription.trialEnd && subscription.trialEnd > now) {
      return true;
    }

    // Check if paid subscription is active
    if (subscription.status === 'active' && subscription.currentPeriodEnd && subscription.currentPeriodEnd > now) {
      return true;
    }

    return false;
  }

  // Update subscription from Link webhook
  static async updateFromLinkWebhook(linkSubscription: any) {
    const subscription = await prisma.subscription.findFirst({
      where: { linkSubscriptionId: linkSubscription.id }
    });

    if (!subscription) {
      throw new Error(`Subscription not found for Link ID: ${linkSubscription.id}`);
    }

    return await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        status: linkSubscription.status,
        currentPeriodStart: new Date(linkSubscription.current_period_start * 1000),
        currentPeriodEnd: new Date(linkSubscription.current_period_end * 1000),
        canceledAt: linkSubscription.canceled_at ? new Date(linkSubscription.canceled_at * 1000) : null
      }
    });
  }

  // Cancel subscription
  static async cancelSubscription(userId: string) {
    const subscription = await this.getUserSubscription(userId);

    if (!subscription) {
      throw new Error('No subscription found');
    }

    return await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        status: 'canceled',
        canceledAt: new Date()
      }
    });
  }
}
```

## Updated Schema for Link Integration

```prisma:prisma/schema.prisma
// ... existing models ...

// Simple Subscription Model for Link Integration
model Subscription {
  id                    String    @id @default(uuid())
  userId                String    @map("user_id")
  linkCustomerId        String?   @map("link_customer_id")
  linkSubscriptionId    String?   @map("link_subscription_id")
  linkPriceId           String?   @map("link_price_id")
  status                String    @default("trialing") // "trialing", "active", "canceled", "past_due", "incomplete"
  currentPeriodStart    DateTime? @map("current_period_start")
  currentPeriodEnd      DateTime? @map("current_period_end")
  trialStart            DateTime? @map("trial_start")
  trialEnd              DateTime? @map("trial_end")
  canceledAt            DateTime? @map("canceled_at")
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")

  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}
```

## Link Integration Helper

```typescript:lib/link.ts
// Link API integration (you'll need to install the Link SDK)
import { Link } from '@link-sdk/node';

const link = new Link({
  secretKey: process.env.LINK_SECRET_KEY!,
  publishableKey: process.env.LINK_PUBLISHABLE_KEY!
});

export class LinkPaymentService {
  // Create a customer
  static async createCustomer(email: string, name?: string) {
    return await link.customers.create({
      email,
      name,
      metadata: {
        source: 'podcast-app'
      }
    });
  }

  // Create a subscription
  static async createSubscription(customerId: string, priceId: string) {
    return await link.subscriptions.create({
      customer: customerId,
      items: [{ price: priceId }],
      payment_behavior: 'default_incomplete',
      payment_settings: { save_default_payment_method: 'on_subscription' },
      expand: ['latest_invoice.payment_intent']
    });
  }

  // Cancel a subscription
  static async cancelSubscription(subscriptionId: string) {
    return await link.subscriptions.cancel(subscriptionId);
  }

  // Create a checkout session
  static async createCheckoutSession(customerId: string, priceId: string, successUrl: string, cancelUrl: string) {
    return await link.checkout.sessions.create({
      customer: customerId,
      payment_method_types: ['card', 'eft'], // Link supports EFT payments
      line_items: [{ price: priceId, quantity: 1 }],
      mode: 'subscription',
      success_url: successUrl,
      cancel_url: cancelUrl,
      allow_promotion_codes: true
    });
  }

  // Handle webhook events
  static async handleWebhook(event: any) {
    switch (event.type) {
      case 'subscription.created':
      case 'subscription.updated':
      case 'subscription.deleted':
        return await LinkService.updateFromLinkWebhook(event.data.object);

      case 'invoice.payment_succeeded':
        // Handle successful payment
        break;

      case 'invoice.payment_failed':
        // Handle failed payment
        break;

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }
  }
}
```

## Environment Variables for Link

```env
# Link Configuration
LINK_SECRET_KEY=lsk_test_...
LINK_PUBLISHABLE_KEY=lkp_test_...
LINK_PREMIUM_PRICE_ID=price_...
LINK_WEBHOOK_SECRET=whsec_...
```

## Benefits of Using Link in South Africa

Based on the [Payfast](https://payfast.io/) and [Ozow](https://ozow.com/) information, Link will give you:

✅ **Local Payment Methods**: EFT, card payments, QR codes
✅ **Better Compliance**: Designed for South African regulations
✅ **Lower Fees**: Competitive rates for local businesses
✅ **Faster Payouts**: Immediate access to funds
✅ **Local Support**: South African customer service
✅ **Multi-Currency**: Support for ZAR and other currencies

## Updated Seed Data with South African Pricing

```typescript:scripts/seed-curated-content.ts
// ... existing code ...

// Update the subscription tiers for South African market
export const SUBSCRIPTION_TIERS = {
  TRIAL: {
    id: 'trial',
    name: 'Free Trial',
    price: 0,
    linkPriceId: null,
    features: ['1 week trial', '1 collection', 'Weekly generation']
  },
  PREMIUM: {
    id: 'premium',
    name: 'Premium',
    price: 99, // R99/month in ZAR
    linkPriceId: process.env.LINK_PREMIUM_PRICE_ID,
    features: ['Unlimited collections', 'Weekly generation', 'Priority support']
  }
} as const;
```

## Migration Command

```bash
# Run this to create the migration with Link fields
npx prisma migrate dev --name add_link_subscription_integration
```

This setup gives you:

✅ **Link integration** instead of Stripe
✅ **South African payment methods** (EFT, cards, QR codes)
✅ **Local pricing** in ZAR
✅ **Better compliance** with SA regulations
✅ **Faster payouts** and local support
✅ **Same simple subscription model** but optimized for SA market

The subscription model remains simple but now works perfectly with Link's South African-focused payment infrastructure. Ready to implement this?

```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export interface SubscriptionTier {
  id: string;
  name: string;
  price: number;
  linkPriceId: string;
  features: string[];
}

export const SUBSCRIPTION_TIERS = {
  TRIAL: {
    id: 'trial',
    name: 'Free Trial',
    price: 0,
    linkPriceId: null,
    features: ['1 week trial', '1 collection', 'Weekly generation']
  },
  PREMIUM: {
    id: 'premium',
    name: 'Premium',
    price: 99, // R99/month in ZAR
    linkPriceId: process.env.LINK_PREMIUM_PRICE_ID,
    features: ['Unlimited collections', 'Weekly generation', 'Priority support']
  }
} as const;

export class LinkService {
  // Create a new subscription (trial or paid)
  static async createSubscription(userId: string, tierId: string) {
    const tier = SUBSCRIPTION_TIERS[tierId as keyof typeof SUBSCRIPTION_TIERS];

    if (!tier) {
      throw new Error(`Invalid subscription tier: ${tierId}`);
    }

    const now = new Date();
    const trialEnd = tierId === 'trial' ? new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000) : null;

    return await prisma.subscription.create({
      data: {
        userId,
        status: tierId === 'trial' ? 'trialing' : 'active',
        trialStart: tierId === 'trial' ? now : null,
        trialEnd,
        currentPeriodStart: now,
        currentPeriodEnd: trialEnd || new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000), // 30 days
        linkPriceId: tier.linkPriceId
      }
    });
  }

  // Get user's current subscription
  static async getUserSubscription(userId: string) {
    return await prisma.subscription.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' }
    });
  }

  // Check if user has active subscription
  static async hasActiveSubscription(userId: string): Promise<boolean> {
    const subscription = await this.getUserSubscription(userId);

    if (!subscription) return false;

    const now = new Date();

    // Check if trial is still active
    if (subscription.status === 'trialing' && subscription.trialEnd && subscription.trialEnd > now) {
      return true;
    }

    // Check if paid subscription is active
    if (subscription.status === 'active' && subscription.currentPeriodEnd && subscription.currentPeriodEnd > now) {
      return true;
    }

    return false;
  }

  // Update subscription from Link webhook
  static async updateFromLinkWebhook(linkSubscription: any) {
    const subscription = await prisma.subscription.findFirst({
      where: { linkSubscriptionId: linkSubscription.id }
    });

    if (!subscription) {
      throw new Error(`Subscription not found for Link ID: ${linkSubscription.id}`);
    }

    return await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        status: linkSubscription.status,
        currentPeriodStart: new Date(linkSubscription.current_period_start * 1000),
        currentPeriodEnd: new Date(linkSubscription.current_period_end * 1000),
        canceledAt: linkSubscription.canceled_at ? new Date(linkSubscription.canceled_at * 1000) : null
      }
    });
  }

  // Cancel subscription
  static async cancelSubscription(userId: string) {
    const subscription = await this.getUserSubscription(userId);

    if (!subscription) {
      throw new Error('No subscription found');
    }

    return await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        status: 'canceled',
        canceledAt: new Date()
      }
    });
  }
}
```

```prisma
// ... existing models ...

// Simple Subscription Model for Link Integration
model Subscription {
  id                    String    @id @default(uuid())
  userId                String    @map("user_id")
  linkCustomerId        String?   @map("link_customer_id")
  linkSubscriptionId    String?   @map("link_subscription_id")
  linkPriceId           String?   @map("link_price_id")
  status                String    @default("trialing") // "trialing", "active", "canceled", "past_due", "incomplete"
  currentPeriodStart    DateTime? @map("current_period_start")
  currentPeriodEnd      DateTime? @map("current_period_end")
  trialStart            DateTime? @map("trial_start")
  trialEnd              DateTime? @map("trial_end")
  canceledAt            DateTime? @map("canceled_at")
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")

  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}
```

```typescript
// Link API integration (you'll need to install the Link SDK)
import { Link } from '@link-sdk/node';

const link = new Link({
  secretKey: process.env.LINK_SECRET_KEY!,
  publishableKey: process.env.LINK_PUBLISHABLE_KEY!
});

export class LinkPaymentService {
  // Create a customer
  static async createCustomer(email: string, name?: string) {
    return await link.customers.create({
      email,
      name,
      metadata: {
        source: 'podcast-app'
      }
    });
  }

  // Create a subscription
  static async createSubscription(customerId: string, priceId: string) {
    return await link.subscriptions.create({
      customer: customerId,
      items: [{ price: priceId }],
      payment_behavior: 'default_incomplete',
      payment_settings: { save_default_payment_method: 'on_subscription' },
      expand: ['latest_invoice.payment_intent']
    });
  }

  // Cancel a subscription
  static async cancelSubscription(subscriptionId: string) {
    return await link.subscriptions.cancel(subscriptionId);
  }

  // Create a checkout session
  static async createCheckoutSession(customerId: string, priceId: string, successUrl: string, cancelUrl: string) {
    return await link.checkout.sessions.create({
      customer: customerId,
      payment_method_types: ['card', 'eft'], // Link supports EFT payments
      line_items: [{ price: priceId, quantity: 1 }],
      mode: 'subscription',
      success_url: successUrl,
      cancel_url: cancelUrl,
      allow_promotion_codes: true
    });
  }

  // Handle webhook events
  static async handleWebhook(event: any) {
    switch (event.type) {
      case 'subscription.created':
      case 'subscription.updated':
      case 'subscription.deleted':
        return await LinkService.updateFromLinkWebhook(event.data.object);

      case 'invoice.payment_succeeded':
        // Handle successful payment
        break;

      case 'invoice.payment_failed':
        // Handle failed payment
        break;

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }
  }
}
```

```env
# Link Configuration
LINK_SECRET_KEY=lsk_test_...
LINK_PUBLISHABLE_KEY=lkp_test_...
LINK_PREMIUM_PRICE_ID=price_...
LINK_WEBHOOK_SECRET=whsec_...
```

```typescript
// ... existing code ...

// Update the subscription tiers for South African market
export const SUBSCRIPTION_TIERS = {
  TRIAL: {
    id: 'trial',
    name: 'Free Trial',
    price: 0,
    linkPriceId: null,
    features: ['1 week trial', '1 collection', 'Weekly generation']
  },
  PREMIUM: {
    id: 'premium',
    name: 'Premium',
    price: 99, // R99/month in ZAR
    linkPriceId: process.env.LINK_PREMIUM_PRICE_ID,
    features: ['Unlimited collections', 'Weekly generation', 'Priority support']
  }
} as const;
```

```shellscript
# Run this to create the migration with Link fields
npx prisma migrate dev --name add_link_subscription_integration
```
