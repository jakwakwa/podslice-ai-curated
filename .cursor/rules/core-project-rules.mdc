---
globs: lib/inngest/**/*.ts
alwaysApply: false
---
# Core Project Rules



## **Core Architectural Mandate: Source URL is the Single Source of Truth**

This document outlines the non-negotiable, fundamental principle for processing media in this application. Its purpose is to eliminate recurring architectural mistakes, specifically the "download first, process later" anti-pattern that has been the root cause of timeout errors and system failures.

#### **1. The Golden Rule: The `srcUrl` is Paramount**

The entire transcription workflow begins with a single input from the user: a `srcUrl`, which is a URL pointing to a YouTube video.

* This `srcUrl` **is the raw material**. It is not a link to a file that needs to be downloaded in its entirety.
* The system must **always** be designed to work directly with this URL.

#### **2. The Forbidden Pattern: No Full, Preliminary Downloads**

Under **NO circumstances** should the system ever attempt to download the full audio or video content from the `srcUrl` as a preliminary step.

* There is, and **will never be**, a "source audio" file stored in Google Cloud Storage (GCS) that is used as an input for transcription.
* The historical Inngest step named `"download-and-store-audio"` is a **deprecated and flawed pattern**. This logic, and any function that replicates its behavior, is the direct cause of timeouts for long videos and must be permanently removed and never reintroduced.
* The system's logic should not depend on the existence of a pre-downloaded source file. It will never exist.

#### **3. The Correct & Only Valid Transcription Workflow**

There are only two valid methods for generating a transcript from the `srcUrl`.

**Method A: Direct API Processing (The Default)**
The primary and most efficient method is to leverage Gemini's video understanding capabilities.
* The workflow provides the `srcUrl` directly to the Gemini model.
* The model itself is responsible for processing the video content from the URL. No local download or storage of the source is required.

**Method B: On-Demand Stream Chunking (For Long Videos)**
To handle videos that exceed a single function's timeout, the process must be chunked by streaming directly from the source.
1.  **Orchestrator (The Saga):** Fetches *only the metadata* of the `srcUrl` to determine its total duration. It **does not** download the file.
2.  **Fan-Out:** The saga calculates the number of chunks required (e.g., 30-minute segments) and dispatches a separate worker job for each chunk.
3.  **Worker:** Each worker receives the **original `srcUrl`** along with its unique `startTime` and `duration`.
4.  **Stream Processing:** The worker uses a tool like `ffmpeg` to process **only its designated segment directly from the `srcUrl`'s stream**. It never handles the full file. The resulting small audio segment is then passed to the transcription model.

#### **Mantra**

To put it simply for any AI or developer:

**Process the stream, not the file. The URL is the source, not a download link.**


### middleware

The middleware file works and it exists. its in .cursorignore to protect it from AI agents. So dont question where its. if you condifer changing middleware, dont I guarantee its not middleware. you must think of what else can be improved or fix what is really wrong with a problem.

## Safe Google Cloud Storage initialization (uploads)

  * For upload routes (e.g., `app/api/admin/upload-episode/route.ts`), use lazy init and support JSON or path credentials.

  * Accept the first available of: `GCS_UPLOADER_KEY_JSON` | `GCS_UPLOADER_KEY` | `GCS_UPLOADER_KEY_PATH`.

  * Never print credentials or absolute paths in logs or errors.

## Server page scaffold (default)

```ts
// app/(protected)/example/page.tsx
import type { Metadata } from "next";
import { Suspense } from "react";
import { z } from "zod"; // Schema validation library
import type { MyData } from "@/lib/types"; // Example type import

export const revalidate = 3600; // Prefer ISR; switch to dynamic with no-store if needed

// Define a Zod schema for your data to ensure type safety
const MyDataSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
});

// Use a Promise type with your data schema
async function fetchData(): Promise<MyData[]> {
  const res = await fetch("/api/example", { next: { revalidate } });
  if (!res.ok) throw new Error("Failed to load");
  const data = await res.json();
  // Validate the data at runtime
  return z.array(MyDataSchema).parse(data) as MyData[];
}

export async function generateMetadata(): Promise<Metadata> {
  return { title: "Example", description: "Example page" };
}

export default async function Page() {
  const dataPromise = fetchData();
  return (
    <Suspense fallback={<div>Loadingâ€¦</div>}>
      {/* Prefer rendering Client Components for interactivity */}
      {/* <ClientComponent data={await dataPromise} /> */}
      <pre>{JSON.stringify(await dataPromise, null, 2)}</pre>
    </Suspense>
  );
}
```

## Client component scaffold (for interactivity only)

```ts
// app/(protected)/example/_components/client-component.tsx
"use client";
import { useState } from "react";
import { Button } from "@/components/ui/button";
import type { MyData } from "@/lib/types"; // Import type from your types file

type ClientProps = {
  data: MyData[];
  label: string;
};

// Use an interface or type for props and destructure them
export function ClientComponent({ data, label }: ClientProps) {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>{label}: {count}</p>
      <Button onClick={() => setCount((n) => n + 1)}>Increment</Button>
    </div>
  );
}
```

## Data, types, and schema

  * **Server Components first**: Fetch on the server. Pass data to Client Components via props only when necessary.


  * **Parallel fetching**: Use `Promise.all` to fetch independent data concurrently.

  * **SEO**: Use `generateMetadata` in `layout.tsx` or `page.tsx` for dynamic SEO metadata.

  * **Types source of truth**: Do not hardcode interfaces in page files. Use Prisma-generated types from `lib/types.ts` and Prisma Client types.

      * Example: `import type { Episode } from "@/lib/types"`.
      * Always use `import type` for type-only imports.
      * **Prisma Field Names**: Always use exact field names as defined in `prisma/schema.prisma` (e.g., `podcast_id`, `published_at`).

## Route handlers and server actions

  * **API**: Place route handlers under `app/api/.../route.ts`. `GET` is static by default unless configured otherwise.

  * **Mutations**: Prefer Server Actions with the `"use server"` directive. In Client Components, use `useFormStatus`, `useFormState`, and `useOptimistic` for UX.

## UI, styling, and assets

  * **UI kit**: Use existing shadcn/ui components like `Button`, `Input`.

  * **Styling**: Use CSS Modules. If you touch a file with Tailwind, replace classes incrementally with module CSS.

  * **Images**: Never use `<img>`. Always use Next.js `<Image />` with proper sizing.

  * **Accessibility**: Provide alt text, labels, and focus states.

### Admin pages

  * Follow the patterns in the `admin-pages-structure` rule (thin pages, Server Components for data, Client for interactivity, safe initialization).

