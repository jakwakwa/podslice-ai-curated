// This is your Prisma schema file
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String                         @id @default(cuid())
  name                  String?
  email                 String                         @unique
  password              String
  image                 String?
  emailVerified         DateTime?
  isAdmin               Boolean                        @default(false) @map("is_admin")
  emailNotifications    Boolean                        @default(true) @map("email_notifications")
  inAppNotifications    Boolean                        @default(true) @map("in_app_notifications")
  userCurationProfiles  UserCurationProfile[] // Renamed from 'collections'
  notifications         Notification[]
  subscriptions         Subscription[]
  feedback              EpisodeFeedback[] // Added for feedback relation
  bundleEpisodeFeedback CuratedBundleEpisodeFeedback[] // Added for bundle episode feedback

  @@map("users")
}

model UserCurationProfile {
  id                 String    @id @default(uuid())
  userId             String    @map("user_id")
  name               String
  status             String    @default("Draft")
  audioUrl           String?   @map("audio_url")
  imageUrl           String?   @map("image_url") // Added for collection image
  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @updatedAt @map("updated_at")
  generatedAt        DateTime? @map("generated_at")
  lastGenerationDate DateTime? @map("last_generation_date")
  nextGenerationDate DateTime? @map("next_generation_date")
  isActive           Boolean   @default(true) @map("is_active")

  // Bundle selection (read-only) or custom selection (editable)
  isBundleSelection Boolean        @default(false) @map("is_bundle_selection")
  selectedBundleId  String?        @map("selected_bundle_id")
  selectedBundle    CuratedBundle? @relation(fields: [selectedBundleId], references: [id])

  // For custom selections (editable)
  sources  Source[]
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  episodes Episode[]

  @@unique([userId]) // One collection per user
  @@map("user_curation_profiles")
}

model Source {
  id                    String               @id @default(uuid())
  userCurationProfileId String?              @map("user_curation_profile_id") // Renamed from 'collectionId'
  name                  String
  url                   String
  imageUrl              String?              @map("image_url") // Added for source image
  createdAt             DateTime             @default(now()) @map("created_at")
  userCurationProfile   UserCurationProfile? @relation(fields: [userCurationProfileId], references: [id], onDelete: SetNull) // Changed onDelete to SetNull
  episodes              Episode[]

  @@map("sources")
}

model Episode {
  id                    String              @id @default(uuid())
  title                 String
  description           String?
  audioUrl              String
  imageUrl              String?             @map("image_url") // Added for episode image
  publishedAt           DateTime?
  weekNr                DateTime?           @map("week_nr") // Added for data analysis and metrics
  createdAt             DateTime            @default(now())
  sourceId              String              @map("source_id")
  source                Source              @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  userCurationProfileId String              @map("user_curation_profile_id")
  userCurationProfile   UserCurationProfile @relation(fields: [userCurationProfileId], references: [id], onDelete: Cascade)
  feedback              EpisodeFeedback[]

  @@map("episodes")
}

// Pre-curated individual podcasts (25 shows)
model CuratedPodcast {
  id          String   @id @default(uuid())
  name        String
  url         String
  description String?
  imageUrl    String? // Added for curated podcast image
  category    String // "Technology", "Business", "Science", "News"
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with bundles
  bundlePodcasts CuratedBundlePodcast[]

  @@map("curated_podcasts")
}

// Pre-curated bundles (3 bundles, 5 shows each)
model CuratedBundle {
  id          String   @id @default(uuid())
  name        String // "Tech Weekly", "Business Insights", "Science & Discovery"
  description String?
  imageUrl    String? // Added for curated bundle image
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Many-to-many with podcasts
  bundlePodcasts       CuratedBundlePodcast[]
  // User Curation Profiles that selected this bundle
  userCurationProfiles UserCurationProfile[] // Renamed from 'collections'
  // Weekly generated episodes for this bundle
  episodes             CuratedBundleEpisode[]

  @@map("curated_bundles")
}

// Junction table for bundle-podcast relationship
model CuratedBundlePodcast {
  id        String         @id @default(uuid())
  bundleId  String         @map("bundle_id")
  podcastId String         @map("podcast_id")
  bundle    CuratedBundle  @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  podcast   CuratedPodcast @relation(fields: [podcastId], references: [id], onDelete: Cascade)

  @@unique([bundleId, podcastId])
  @@map("curated_bundle_podcasts")
}

// Weekly generated episodes for curated bundles
model CuratedBundleEpisode {
  id          String   @id @default(uuid())
  title       String
  description String?
  audioUrl    String
  imageUrl    String?  @map("image_url")
  publishedAt DateTime @default(now()) @map("published_at")
  weekNr      DateTime @map("week_nr") // Week number for tracking
  createdAt   DateTime @default(now()) @map("created_at")

  // Bundle this episode belongs to
  bundleId String        @map("bundle_id")
  bundle   CuratedBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)

  // Feedback for bundle episodes
  feedback CuratedBundleEpisodeFeedback[]

  @@map("curated_bundle_episodes")
}

// Feedback for curated bundle episodes
model CuratedBundleEpisodeFeedback {
  id        String         @id @default(uuid())
  userId    String         @map("user_id")
  episodeId String         @map("episode_id")
  rating    FeedbackRating
  createdAt DateTime       @default(now()) @map("created_at")
  updatedAt DateTime       @updatedAt @map("updated_at")

  user    User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  episode CuratedBundleEpisode @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  @@unique([userId, episodeId])
  @@map("curated_bundle_episode_feedback")
}

// Notifications
model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      String // "episode_ready", "weekly_reminder"
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

// Simple Subscription Model for Link Integration
model Subscription {
  id                 String    @id @default(uuid())
  userId             String    @map("user_id")
  linkCustomerId     String?   @map("link_customer_id")
  linkSubscriptionId String?   @map("link_subscription_id")
  linkPriceId        String?   @map("link_price_id")
  status             String    @default("trialing") // "trialing", "active", "canceled", "past_due", "incomplete"
  currentPeriodStart DateTime? @map("current_period_start")
  currentPeriodEnd   DateTime? @map("current_period_end")
  trialStart         DateTime? @map("trial_start")
  trialEnd           DateTime? @map("trial_end")
  canceledAt         DateTime? @map("canceled_at")
  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

// Enum for feedback rating
enum FeedbackRating {
  THUMBS_UP
  THUMBS_DOWN
  NEUTRAL
}

// Episode Feedback model
model EpisodeFeedback {
  id        String         @id @default(uuid())
  userId    String         @map("user_id")
  episodeId String         @map("episode_id")
  rating    FeedbackRating
  createdAt DateTime       @default(now()) @map("created_at")
  updatedAt DateTime       @updatedAt @map("updated_at")

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  episode Episode @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  @@unique([userId, episodeId])
  @@map("episode_feedback")
}
