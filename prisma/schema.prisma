// This is your Prisma schema file
generator client {
    provider      = "prisma-client-js"
    binaryTargets = ["native", "linux-musl"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model User {
    id            String         @id @default(cuid())
    name          String?
    email         String         @unique
    password      String
    image         String?
    emailVerified DateTime?
    emailNotifications Boolean @default(true) @map("email_notifications")
    inAppNotifications Boolean @default(true) @map("in_app_notifications")
    collections   Collection[]
    notifications Notification[]
    subscriptions Subscription[]

    @@map("users")
}

model Collection {
    id          String    @id @default(uuid())
    userId      String    @map("user_id")
    name        String
    status      String    @default("Draft")
    audioUrl    String?   @map("audio_url")
    imageUrl    String?   @map("image_url") // Added for collection image
    createdAt   DateTime  @default(now()) @map("created_at")
    updatedAt   DateTime  @updatedAt @map("updated_at")
    generatedAt DateTime? @map("generated_at")
    lastGenerationDate DateTime? @map("last_generation_date")
    nextGenerationDate DateTime? @map("next_generation_date")
    isActive    Boolean   @default(true) @map("is_active")

    // Bundle selection (read-only) or custom selection (editable)
    isBundleSelection Boolean @default(false) @map("is_bundle_selection")
    selectedBundleId  String? @map("selected_bundle_id")
    selectedBundle    CuratedBundle? @relation(fields: [selectedBundleId], references: [id])

    // For custom selections (editable)
    sources     Source[]
    user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    episodes    Episode[]

    @@unique([userId]) // One collection per user
    @@map("collections")
}

model Source {
    id           String     @id @default(uuid())
    collectionId String     @map("collection_id")
    name         String
    url          String
    imageUrl     String?    @map("image_url") // Added for source image
    createdAt    DateTime   @default(now()) @map("created_at")
    collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
    episodes     Episode[]

    @@map("sources")
}

model Episode {
    id           String     @id @default(uuid())
    title        String
    description  String?
    audioUrl     String
    imageUrl     String?    @map("image_url") // Added for episode image
    publishedAt  DateTime?
    createdAt    DateTime   @default(now())
    sourceId     String     @map("source_id")
    source       Source     @relation(fields: [sourceId], references: [id], onDelete: Cascade)
    collectionId String     @map("collection_id")
    collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

    @@map("episodes")
}

// Pre-curated individual podcasts (25 shows)
model CuratedPodcast {
    id          String   @id @default(uuid())
    name        String
    url         String
    description String?
    imageUrl    String?  // Added for curated podcast image
    category    String   // "Technology", "Business", "Science", "News"
    isActive    Boolean  @default(true)
    createdAt   DateTime @default(now())

    // Many-to-many with bundles
    bundlePodcasts CuratedBundlePodcast[]

    @@map("curated_podcasts")
}

// Pre-curated bundles (3 bundles, 5 shows each)
model CuratedBundle {
    id          String   @id @default(uuid())
    name        String   // "Tech Weekly", "Business Insights", "Science & Discovery"
    description String?
    imageUrl    String?  // Added for curated bundle image
    isActive    Boolean  @default(true)
    createdAt   DateTime @default(now())

    // Many-to-many with podcasts
    bundlePodcasts CuratedBundlePodcast[]
    // Collections that selected this bundle
    collections Collection[]

    @@map("curated_bundles")
}

// Junction table for bundle-podcast relationship
model CuratedBundlePodcast {
    id              String        @id @default(uuid())
    bundleId        String        @map("bundle_id")
    podcastId       String        @map("podcast_id")
    bundle          CuratedBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
    podcast         CuratedPodcast @relation(fields: [podcastId], references: [id], onDelete: Cascade)

    @@unique([bundleId, podcastId])
    @@map("curated_bundle_podcasts")
}

// Notifications
model Notification {
    id        String   @id @default(uuid())
    userId    String   @map("user_id")
    type      String   // "episode_ready", "weekly_reminder"
    message   String
    isRead    Boolean  @default(false)
    createdAt DateTime @default(now())
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("notifications")
}

// Simple Subscription Model for Link Integration
model Subscription {
    id                 String    @id @default(uuid())
    userId             String    @map("user_id")
    linkCustomerId     String?   @map("link_customer_id")
    linkSubscriptionId String?   @map("link_subscription_id")
    linkPriceId        String?   @map("link_price_id")
    status             String    @default("trialing") // "trialing", "active", "canceled", "past_due", "incomplete"
    currentPeriodStart DateTime? @map("current_period_start")
    currentPeriodEnd   DateTime? @map("current_period_end")
    trialStart         DateTime? @map("trial_start")
    trialEnd           DateTime? @map("trial_end")
    canceledAt         DateTime? @map("canceled_at")
    createdAt          DateTime  @default(now()) @map("created_at")
    updatedAt          DateTime  @updatedAt @map("updated_at")

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("subscriptions")
}
