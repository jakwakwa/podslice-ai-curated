// Import Prisma types and enums (now as a value too)
import { PlanGate, UserRole, type Prisma, type FeedbackRating as PrismaFeedbackRating } from "@prisma/client";

// Base scalar model shapes derived from Prisma payloads (compatible with Prisma v6)
export type User = Prisma.$UserPayload["scalars"];
export type UserCurationProfile = Prisma.$UserCurationProfilePayload["scalars"];
export type Podcast = Prisma.$PodcastPayload["scalars"];
export type Bundle = Prisma.$BundlePayload["scalars"];
export type Episode = Prisma.$EpisodePayload["scalars"];
export type BundlePodcast = Prisma.$BundlePodcastPayload["scalars"];
export type ProfilePodcast = Prisma.$ProfilePodcastPayload["scalars"];
export type Notification = Prisma.$NotificationPayload["scalars"];
export type Subscription = Prisma.$SubscriptionPayload["scalars"];
export type EpisodeFeedback = Prisma.$EpisodeFeedbackPayload["scalars"];
export type FeedbackRating = PrismaFeedbackRating;
export type UserEpisode = Prisma.$UserEpisodePayload["scalars"];
export { UserRole };

// Custom types that combine Prisma types with relations
export type UserCurationProfileWithRelations = UserCurationProfile & {
	selectedBundle?: (Bundle & { podcasts: Podcast[]; episodes: Episode[] }) | null;
	episode: Episode[];
};

// Source type for podcast sources
export interface Source {
	id: string;
	name: string;
	url: string;
	image_url?: string;
}

export type SubscriptionWithRelations = Subscription & {
	user: User;
	paymentProcessor: "paddle";
	planType: PlanGate;
	status: "trialing" | "active" | "cancelled";
	currentPeriodStart: Date;
	currentPeriodEnd: Date;
	trialStart: Date;
	trialEnd: Date;
	canceledAt: Date;
	cancelAtPeriodEnd: boolean;
};

// --- New Branded Type for Product Plans ---

// Step 1: Define the specific string literals that are valid product plans.
type ValidProductPlan = "Casual Listener" | "Free Slice" | "Curate Control";

// Step 2: Create a branded type that is a string, but also one of the valid plans.
// This ensures that only validated strings can be used for the product plan.
export type ProductPlan = ValidProductPlan & { readonly __brand: unique symbol };

// Step 3: Create a mapping object that translates the validated product plan to a PlanGate enum.
const _productPlanToPlanGateMap: Record<ValidProductPlan, PlanGate> = {
	"Casual Listener": PlanGate.CASUAL_LISTENER,
	"Free Slice": PlanGate.FREE_SLICE,
	"Curate Control": PlanGate.CURATE_CONTROL,
};

// Step 4: A factory function to validate and convert a raw string to a type-safe object.
// export function createProductPlan(productName: string): { productPlan: ProductPlan; planGate: PlanGate } {
// 	// Check if the productName is a valid key in our map.
// 	if (!(productName in productPlanToPlanGateMap)) {
// 		throw new Error(`Invalid product plan name: "${productName}".`)
// 	}

// 	// We are certain this is a valid key, so we can cast it to satisfy TypeScript.
// 	const validatedPlanName = productName as ValidProductPlan

// 	// Create the branded type from the validated string.
// 	const brandedProductPlan = validatedPlanName as ProductPlan

// 	return {
// 		productPlan: brandedProductPlan,
// 		planGate: productPlanToPlanGateMap[validatedPlanName],
// 	}
// }

// Your interface using the new type

export interface PlanTier {
	planId: PlanGate;
	productTitle: string;
	icon: string;
	description: string;
	features: string[];
	featured: boolean;
	priceId: string;
	episodeLimit: number;
}

// Only keep custom types that can't be generated by Prisma
export interface FormState {
	success: boolean;
	message: string;
	error: string | null | undefined;
}

export interface IBillingFrequency {
	value: string;
	label: string;
	priceSuffix: string;
}

export type PaddleCheckoutCompletedData = {
	transaction_id: string;
	status: string;
	customer: {
		id: string;
	};
	items: {
		price_id: string;
	}[];
};
