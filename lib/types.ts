// Import Prisma types and enums (now as a value too)
import { PlanGate, type Prisma, type FeedbackRating as PrismaFeedbackRating } from "@prisma/client"

// Base scalar model shapes derived from Prisma payloads (compatible with Prisma v6)
export type User = Prisma.$UserPayload["scalars"]
export type UserCurationProfile = Prisma.$UserCurationProfilePayload["scalars"]
export type Podcast = Prisma.$PodcastPayload["scalars"]
export type Bundle = Prisma.$BundlePayload["scalars"]
export type Episode = Prisma.$EpisodePayload["scalars"]
export type BundlePodcast = Prisma.$BundlePodcastPayload["scalars"]
export type ProfilePodcast = Prisma.$ProfilePodcastPayload["scalars"]
export type Notification = Prisma.$NotificationPayload["scalars"]
export type Subscription = Prisma.$SubscriptionPayload["scalars"]
export type EpisodeFeedback = Prisma.$EpisodeFeedbackPayload["scalars"]
export type FeedbackRating = PrismaFeedbackRating

// Custom types that combine Prisma types with relations
export type UserCurationProfileWithRelations = UserCurationProfile & {
	selectedBundle?: (Bundle & { podcasts: Podcast[]; episodes: Episode[] }) | null
	episode: Episode[]
}

// Source type for podcast sources
export interface Source {
	id: string
	name: string
	url: string
	image_url?: string
}

export type SubscriptionWithRelations = Subscription & {
	user: User
	paymentProcessor: "paddle"
	planType: PlanGate
	status: "trialing" | "active" | "cancelled"
	currentPeriodStart: Date
	currentPeriodEnd: Date
	trialStart: Date
	trialEnd: Date
	canceledAt: Date
	cancelAtPeriodEnd: boolean
}

// --- Branded Types for Validation ---

// Part 1: The Branded Primitive Type for Paddle IDs
// This type is a standard string with a unique, non-existent property.
// The TypeScript compiler treats it as a distinct type, which is simple and efficient.
export type PaddlePriceId = string & { readonly __brand: unique symbol }

// Part 2: The Factory/Validation Function for Paddle IDs
// This is a single, clear function that enforces all your rules.
// It ensures that only correctly formatted strings can become a PaddlePriceId.
export function createPaddlePriceId(value: string): PaddlePriceId {
	const prefix = "pri_"
	const suffixLength = 26
	const regex = /^[0-9a-f]{26}$/

	if (!value.startsWith(prefix) || value.length !== prefix.length + suffixLength || !regex.test(value.substring(prefix.length))) {
		throw new Error(`Invalid PaddlePriceId format: "${value}". Expected a string starting with "${prefix}" and followed by ${suffixLength} hexadecimal characters.`)
	}

	// The key step: we cast the validated string to our branded type.
	// This is safe because we have just validated it.
	return value as PaddlePriceId
}

// --- New Branded Type for Product Plans ---

// Step 1: Define the specific string literals that are valid product plans.
type ValidProductPlan = "Casual Listener" | "Free Slice" | "Curate Control"

// Step 2: Create a branded type that is a string, but also one of the valid plans.
// This ensures that only validated strings can be used for the product plan.
export type ProductPlan = ValidProductPlan & { readonly __brand: unique symbol }

// Step 3: Create a mapping object that translates the validated product plan to a PlanGate enum.
const productPlanToPlanGateMap: Record<ValidProductPlan, PlanGate> = {
	"Casual Listener": PlanGate.CASUAL_LISTENER,
	"Free Slice": PlanGate.FREE_SLICE,
	"Curate Control": PlanGate.CURATE_CONTROL,
}

// Step 4: A factory function to validate and convert a raw string to a type-safe object.
export function createProductPlan(productName: string): { productPlan: ProductPlan; planGate: PlanGate } {
	// Check if the productName is a valid key in our map.
	if (!(productName in productPlanToPlanGateMap)) {
		throw new Error(`Invalid product plan name: "${productName}".`)
	}

	// We are certain this is a valid key, so we can cast it to satisfy TypeScript.
	const validatedPlanName = productName as ValidProductPlan

	// Create the branded type from the validated string.
	const brandedProductPlan = validatedPlanName as ProductPlan

	return {
		productPlan: brandedProductPlan,
		planGate: productPlanToPlanGateMap[validatedPlanName],
	}
}

// Your interface using the new type
export interface IPaddleProductPlan {
	priceId: PaddlePriceId
	priceName: PlanGate
	product: ProductPlan // This now expects our new branded type
	price: string
}

// Only keep custom types that can't be generated by Prisma
export interface FormState {
	success: boolean
	message: string
	error: string | null | undefined
}
