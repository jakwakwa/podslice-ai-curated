// Import Prisma types and enums (using fallback types)
import { PlanGate, UserRole, FeedbackRating as PrismaFeedbackRating } from "@/types/prisma-fallback"

// Base scalar model shapes - using fallback types when Prisma client generation fails
export type User = import("@/types/prisma-fallback").User
export type UserCurationProfile = import("@/types/prisma-fallback").UserCurationProfile  
export type Podcast = import("@/types/prisma-fallback").Podcast
export type Bundle = import("@/types/prisma-fallback").Bundle
export type Episode = import("@/types/prisma-fallback").Episode
export type BundlePodcast = any // Simplified for now
export type ProfilePodcast = any // Simplified for now
export type Notification = any // Simplified for now
export type Subscription = any // Simplified for now
export type EpisodeFeedback = any // Simplified for now
export type FeedbackRating = PrismaFeedbackRating
export type UserEpisode = import("@/types/prisma-fallback").UserEpisode
export { UserRole }

// Custom types that combine Prisma types with relations
export type UserCurationProfileWithRelations = UserCurationProfile & {
	selectedBundle?: (Bundle & { podcasts: Podcast[]; episodes: Episode[] }) | null
	episode: Episode[]
}

// Source type for podcast sources
export interface Source {
	id: string
	name: string
	url: string
	image_url?: string
}

export type SubscriptionWithRelations = Subscription & {
	user: User
	paymentProcessor: "paddle"
	planType: PlanGate
	status: "trialing" | "active" | "cancelled"
	currentPeriodStart: Date
	currentPeriodEnd: Date
	trialStart: Date
	trialEnd: Date
	canceledAt: Date
	cancelAtPeriodEnd: boolean
}

// --- New Branded Type for Product Plans ---

// Step 1: Define the specific string literals that are valid product plans.
type ValidProductPlan = "Casual Listener" | "Free Slice" | "Curate Control"

// Step 2: Create a branded type that is a string, but also one of the valid plans.
// This ensures that only validated strings can be used for the product plan.
export type ProductPlan = ValidProductPlan & { readonly __brand: unique symbol }

// Step 3: Create a mapping object that translates the validated product plan to a PlanGate enum.
const _productPlanToPlanGateMap: Record<ValidProductPlan, PlanGate> = {
	"Casual Listener": PlanGate.CASUAL_LISTENER,
	"Free Slice": PlanGate.FREE_SLICE,
	"Curate Control": PlanGate.CURATE_CONTROL,
}

// Step 4: A factory function to validate and convert a raw string to a type-safe object.
// export function createProductPlan(productName: string): { productPlan: ProductPlan; planGate: PlanGate } {
// 	// Check if the productName is a valid key in our map.
// 	if (!(productName in productPlanToPlanGateMap)) {
// 		throw new Error(`Invalid product plan name: "${productName}".`)
// 	}

// 	// We are certain this is a valid key, so we can cast it to satisfy TypeScript.
// 	const validatedPlanName = productName as ValidProductPlan

// 	// Create the branded type from the validated string.
// 	const brandedProductPlan = validatedPlanName as ProductPlan

// 	return {
// 		productPlan: brandedProductPlan,
// 		planGate: productPlanToPlanGateMap[validatedPlanName],
// 	}
// }

// Your interface using the new type

export interface PlanTier {
	planId: PlanGate
	productTitle: string
	icon: string
	description: string
	features: string[]
	featured: boolean
	priceId: string
	episodeLimit: number
}

// Only keep custom types that can't be generated by Prisma
export interface FormState {
	success: boolean
	message: string
	error: string | null | undefined
}

export interface IBillingFrequency {
	value: string
	label: string
	priceSuffix: string
}

export type PaddleCheckoutCompletedData = {
	transaction_id: string
	status: string
	customer: {
		id: string
	}
	items: {
		price_id: string
	}[]
}
