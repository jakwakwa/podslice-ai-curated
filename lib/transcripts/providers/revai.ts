import { incrementPaidServiceUsage } from "@/lib/usage/service-usage"
import type { TranscriptProvider, TranscriptRequest, TranscriptResponse } from "../types"

interface RevAiJobResponse {
	id: string
	status: string
}

async function startRevAiJob(audioUrl: string, apiKey: string): Promise<string> {
	incrementPaidServiceUsage("revai")
	const res = await fetch("https://api.rev.ai/speechtotext/v1/jobs", {
		method: "POST",
		headers: {
			Authorization: `Bearer ${apiKey}`,
			"Content-Type": "application/json",
		},
		body: JSON.stringify({
			media_url: audioUrl,
			metadata: "auto-generated by orchestrator",
		}),
	})
	if (!res.ok) {
		const text = await res.text()
		throw new Error(`Rev.ai job start failed: ${text}`)
	}
	const data = (await res.json()) as RevAiJobResponse
	return data.id
}

async function getRevAiJobStatus(jobId: string, apiKey: string): Promise<RevAiJobResponse> {
	const res = await fetch(`https://api.rev.ai/speechtotext/v1/jobs/${jobId}`, {
		headers: { Authorization: `Bearer ${apiKey}` },
	})
	if (!res.ok) {
		const text = await res.text()
		throw new Error(`Rev.ai job status failed: ${text}`)
	}
	return (await res.json()) as RevAiJobResponse
}

async function getRevAiTranscript(jobId: string, apiKey: string): Promise<string> {
	const res = await fetch(`https://api.rev.ai/speechtotext/v1/jobs/${jobId}/transcript`, {
		headers: { Authorization: `Bearer ${apiKey}` },
	})
	if (!res.ok) {
		const text = await res.text()
		throw new Error(`Rev.ai transcript fetch failed: ${text}`)
	}
	return await res.text()
}

function isUrlLikelyAudio(url: string): boolean {
	return /(\.mp3|\.m4a|\.wav|\.aac|\.flac)(\b|$)/i.test(url)
}

export const RevAiProvider: TranscriptProvider = {
	name: "revai",
	canHandle(request) {
		return Boolean(request.allowPaid) && isUrlLikelyAudio(request.url)
	},
	async getTranscript(request: TranscriptRequest): Promise<TranscriptResponse> {
		const apiKey = process.env.REVAI_API_KEY
		if (!apiKey) return { success: false, error: "Rev.ai API key not configured", provider: this.name }
		try {
			// Submit job
			const jobId = await startRevAiJob(request.url, apiKey)
			// Short polling loop (webhooks recommended in production)
			const timeoutMs = 15000
			const start = Date.now()
			while (Date.now() - start < timeoutMs) {
				const status = await getRevAiJobStatus(jobId, apiKey)
				if (status.status === "transcribed" || status.status === "completed") {
					const transcript = await getRevAiTranscript(jobId, apiKey)
					return { success: true, transcript, provider: this.name, meta: { jobId } }
				}
				if (status.status === "failed") {
					return { success: false, error: "Rev.ai job failed", provider: this.name, meta: { jobId } }
				}
				await new Promise(r => setTimeout(r, 1500))
			}
			// Timed out; instruct caller to retry later
			return { success: false, error: "Rev.ai job in progress; retry later", provider: this.name }
		} catch (error) {
			return { success: false, error: error instanceof Error ? error.message : "Rev.ai error", provider: this.name }
		}
	},
}
